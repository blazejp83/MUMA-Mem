---
phase: 01-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/store/sqlite.ts
  - package.json
autonomous: true
---

<objective>
Implement the SQLite storage backend with CRUD operations, sqlite-vec vector search, and per-user isolation.

Purpose: STORE-02 requires SQLite as degraded fallback when Redis is unavailable. STORE-01 (persistence via file), STORE-03 (user isolation via WHERE clauses). SQLite provides single-user operation without Redis dependency.

Output: SQLiteMemoryStore class implementing the MemoryStore interface with vector search via sqlite-vec extension.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@src/types/note.ts
@src/types/store.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SQLiteMemoryStore CRUD operations</name>
  <files>src/store/sqlite.ts, package.json</files>
  <action>
  1. Install: `pnpm add better-sqlite3 sqlite-vec` and `pnpm add -D @types/better-sqlite3`

  2. **src/store/sqlite.ts** — SQLiteMemoryStore class implementing MemoryStore:

  Constructor takes sqlite config (path) and embedding dimensions.

  **initialize()**:
  - Open database: `new Database(config.path)` (better-sqlite3)
  - Load sqlite-vec extension: `sqliteVec.load(db)`
  - Enable WAL mode: `db.pragma("journal_mode = WAL")` for concurrent read performance
  - Create notes table:
    ```sql
    CREATE TABLE IF NOT EXISTS notes (
      id TEXT PRIMARY KEY,
      content TEXT NOT NULL,
      context TEXT NOT NULL DEFAULT '',
      keywords TEXT NOT NULL DEFAULT '[]',
      tags TEXT NOT NULL DEFAULT '[]',
      links TEXT NOT NULL DEFAULT '[]',
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL,
      created_by TEXT NOT NULL,
      user_id TEXT NOT NULL,
      domain TEXT NOT NULL DEFAULT '',
      visibility TEXT NOT NULL DEFAULT 'scoped',
      access_count INTEGER NOT NULL DEFAULT 0,
      access_log TEXT NOT NULL DEFAULT '[]',
      activation REAL NOT NULL DEFAULT 0,
      half_life REAL NOT NULL DEFAULT 168,
      importance REAL NOT NULL DEFAULT 0.5,
      source TEXT NOT NULL DEFAULT 'experience',
      confidence REAL NOT NULL DEFAULT 0.5,
      version INTEGER NOT NULL DEFAULT 1,
      pinned INTEGER NOT NULL DEFAULT 0
    )
    ```
  - Create index on user_id: `CREATE INDEX IF NOT EXISTS idx_notes_user ON notes(user_id)`
  - Create index on domain: `CREATE INDEX IF NOT EXISTS idx_notes_domain ON notes(user_id, domain)`
  - Create index on visibility: `CREATE INDEX IF NOT EXISTS idx_notes_vis ON notes(user_id, visibility)`
  - Vector table creation is deferred until dimensions are known (see Task 2)

  **create(noteCreate)**:
  - Generate UUID via `crypto.randomUUID()`
  - Populate all defaults (same defaults as Redis backend)
  - INSERT into notes table
  - INSERT embedding into vec table (if vec table exists; create it on first embedding)
  - Array fields (keywords, tags, links, access_log) stored as JSON strings
  - `pinned` stored as INTEGER (0/1)
  - Return full Note object

  **read(id, userId)**:
  - SELECT from notes WHERE id = ? AND user_id = ?
  - If no row → return null
  - Fetch embedding from vec table by rowid
  - Deserialize: parse JSON arrays, convert embedding buffer to Float32Array, boolean for pinned
  - Return Note

  **update(id, userId, updates)**:
  - Read existing first
  - If not found → return null
  - Build UPDATE SET clause for only changed fields
  - Bump version, set updated_at
  - If embedding changed, update vec table too
  - Return updated Note

  **delete(id, userId)**:
  - DELETE FROM notes WHERE id = ? AND user_id = ?
  - DELETE from vec table by rowid
  - Return true if rows affected > 0

  **listByUser(userId, options)**:
  - SELECT FROM notes WHERE user_id = ? LIMIT ? OFFSET ?
  - Fetch embeddings for returned notes
  - Return Note[]

  **countByUser(userId)**:
  - SELECT COUNT(*) FROM notes WHERE user_id = ?

  **close()**:
  - db.close()

  Use prepared statements (db.prepare()) for all queries — better-sqlite3 is synchronous, which is fine for SQLite. Wrap in a class that implements the async MemoryStore interface by wrapping sync calls.

  **Row ID mapping**: Use a separate mapping table or store note IDs as rowids in the vec table. The vec0 virtual table uses INTEGER rowids, so maintain a mapping: `notes.rowid` ↔ `vec_notes.rowid`. Use `notes` table's implicit rowid.
  </action>
  <verify>`pnpm run typecheck` passes — SQLiteMemoryStore compiles with full MemoryStore interface</verify>
  <done>SQLiteMemoryStore CRUD operations implemented with better-sqlite3. Notes in SQL table, embeddings in vec0 virtual table. User isolation via WHERE user_id = ?.</done>
</task>

<task type="auto">
  <name>Task 2: Implement vector search and deferred vec table creation</name>
  <files>src/store/sqlite.ts</files>
  <action>
  Add to the existing SQLiteMemoryStore class:

  **Deferred vec table creation**:
  - The vec0 virtual table requires knowing the embedding dimensions at creation time
  - If dimensions are specified in config, create vec table in initialize():
    ```sql
    CREATE VIRTUAL TABLE IF NOT EXISTS vec_notes USING vec0(
      note_rowid INTEGER PRIMARY KEY,
      embedding float[{dimensions}]
    )
    ```
  - If dimensions not in config, defer creation until first note with embedding is created
  - On first create() with embedding: detect dimensions from embedding.length, create vec table, set this._dimensions
  - Store a flag `_vecTableCreated: boolean`

  **search(options)** implementation:
  - If vec table not created → return empty array
  - Query:
    ```sql
    SELECT
      n.*,
      v.distance
    FROM vec_notes v
    INNER JOIN notes n ON n.rowid = v.note_rowid
    WHERE v.embedding MATCH ?
      AND k = ?
      AND n.user_id = ?
    ORDER BY v.distance ASC
    ```
  - Pass query vector as `Float32Array.from(options.query).buffer` (raw buffer)
  - k = options.topK ?? 10
  - Convert distance to similarity score: `score = 1 - distance` (for cosine distance)
  - Apply minScore filter after query
  - Return VectorSearchResult[]

  **Note on vec0 query syntax**: sqlite-vec uses `MATCH` with the raw float buffer and `k = N` in the WHERE clause for KNN. The distance column is automatically added. Test exact syntax — may need:
  ```sql
  SELECT rowid, distance FROM vec_notes WHERE embedding MATCH ? AND k = ?
  ```
  Then join with notes table separately.

  **Embedding storage in create/update**:
  - On create: `INSERT INTO vec_notes(note_rowid, embedding) VALUES(?, ?)` with the notes table rowid and Float32Array buffer
  - On update with new embedding: DELETE old vec row, INSERT new one
  - On delete: `DELETE FROM vec_notes WHERE note_rowid = ?`

  **User isolation**:
  - The join with notes table ensures user_id filter applies
  - vec_notes itself doesn't store user_id (avoids duplication)
  - The KNN query returns more candidates than needed, then the join + WHERE user_id filters

  **Important**: better-sqlite3 is synchronous. All MemoryStore methods return Promises, so wrap with `Promise.resolve()` or use async method bodies that just run sync code.
  </action>
  <verify>
  - `pnpm run typecheck` passes
  - Write a test script (test/sqlite-smoke.ts) that:
    1. Creates SQLiteMemoryStore with in-memory DB (":memory:")
    2. Initializes with dimensions=384
    3. Creates a note with a random 384-dim Float32Array embedding
    4. Reads it back, verifies all fields round-trip correctly
    5. Searches with same embedding, expects note returned
    6. Deletes the note, verifies count = 0
    7. Closes
    8. Run with: `npx tsx test/sqlite-smoke.ts`
  </verify>
  <done>Vector search works via sqlite-vec vec0 virtual table with cosine distance. Deferred vec table creation handles unknown dimensions. User isolation via JOIN with notes table WHERE user_id filter.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes with zero errors
- [ ] SQLiteMemoryStore fully implements MemoryStore interface
- [ ] sqlite-vec extension loads successfully
- [ ] CRUD operations round-trip all 22 Note fields correctly
- [ ] Vector search returns nearest neighbors by cosine distance
- [ ] User isolation enforced via WHERE user_id = ? on all operations
- [ ] Deferred vec table creation works when dimensions not initially known
</verification>

<success_criteria>

- All tasks completed
- SQLiteMemoryStore implements complete MemoryStore interface
- Vector search uses sqlite-vec with cosine distance
- User isolation at SQL WHERE clause level
- Graceful handling of missing vec table (returns empty results)
- Smoke test passes with in-memory database
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
