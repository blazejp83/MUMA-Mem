---
phase: 02-core-memory
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/pipeline/read.ts, src/pipeline/index.ts]
autonomous: true
---

<objective>
Implement the read pipeline — semantic search with top-k control and 1-hop link expansion.

Purpose: Agents need to search memories by natural language query (SEARCH-01) with top-k control (SEARCH-04) within 200ms (SEARCH-02). Search results include linked notes for expanded context (LINK-02).
Output: search() function that embeds a query, performs vector search, and optionally expands results with 1-hop linked notes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/store.ts
@src/types/note.ts
@src/embedding/types.ts
@src/plugin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement semantic search with top-k and link expansion</name>
  <files>src/pipeline/read.ts</files>
  <action>
Create src/pipeline/read.ts with a search function.

Types:
```typescript
export interface SearchOptions {
  query: string;              // Natural language query
  userId: string;
  topK?: number;              // Default 10
  minScore?: number;          // Minimum similarity threshold
  expandLinks?: boolean;      // Default true — include 1-hop linked notes
}

export interface SearchResult {
  note: Note;
  score: number;              // Similarity score from vector search
  linkedNotes?: Note[];       // 1-hop linked notes (if expandLinks=true)
}
```

Implementation of `search(options: SearchOptions): Promise<SearchResult[]>`:
1. Get store and embedding provider via getStore()/getEmbeddingProvider()
2. Embed query text: `const queryEmbedding = await embeddingProvider.embed(options.query)`
3. Call store.search({ query: queryEmbedding, userId, topK, minScore })
4. If expandLinks (default true):
   - Collect unique linked note IDs from all results (note.links arrays), excluding IDs already in results
   - Batch-fetch linked notes via store.read() for each ID (filter by userId for isolation)
   - Attach linkedNotes array to each SearchResult
   - Linked notes that return null (deleted or wrong user) are silently skipped
5. Record access: for each returned note, call store.update(note.id, userId, {}) to bump access_count/access_log
   - IMPORTANT: Do NOT await these updates — fire-and-forget to keep search fast (SEARCH-02: 200ms target)
   - Actually, the store.update currently doesn't auto-bump access_count. Instead, after search is complete, fire off access tracking as a non-blocking side effect. For now, track access by calling store.update() with an empty update — the store implementations should handle access_count/access_log bumping internally on read. If they don't yet, skip access tracking for now (Phase 3 ACT-R will add it).

Return sorted results (already sorted by score from store.search).

Do NOT:
- Add visibility filtering (Phase 4: Multi-Agent)
- Add activation-weighted scoring (Phase 3: Intelligence)
- Add domain boosting (Phase 3/4)
- Import LLM provider (read pipeline doesn't need LLM)
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>search() function exported, takes natural language query string, returns SearchResult[] with optional 1-hop link expansion</done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline barrel export</name>
  <files>src/pipeline/index.ts</files>
  <action>
Create src/pipeline/index.ts as the barrel export for the pipeline module.

For now, export from read.ts:
```typescript
export { search } from "./read.js";
export type { SearchOptions, SearchResult } from "./read.js";
```

This file will be extended by later plans (03, 04, 05) to export write pipeline functions and agent tools.

Also update src/index.ts to re-export pipeline types:
```typescript
export { search } from "./pipeline/index.js";
export type { SearchOptions, SearchResult } from "./pipeline/index.js";
```
  </action>
  <verify>npx tsc --noEmit passes; grep -q "search" src/index.ts</verify>
  <done>Pipeline barrel exports search function, main index.ts re-exports it</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds
- [ ] src/pipeline/read.ts exports search() with SearchOptions/SearchResult types
- [ ] src/pipeline/index.ts barrel exports search
- [ ] src/index.ts re-exports search from pipeline
- [ ] No new dependencies added (uses existing store + embedding)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- search() accepts natural language string query (not raw embedding)
- search() supports top-k parameter
- search() includes 1-hop linked notes by default
- No LLM dependency (read pipeline is pure vector search)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-core-memory/02-02-SUMMARY.md`
</output>
