---
phase: 11-integration-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/__tests__/gateway-lifecycle.test.ts
  - src/__tests__/session-lifecycle.test.ts
autonomous: true
---

<objective>
Test hook handler behaviors through the full plugin lifecycle — gateway start/stop and session start through end.

Purpose: Verify hooks correctly initialize infrastructure, manage working memory sessions, capture episodic memories, promote L1→L2, and clean up.
Output: 2 test files covering gateway and session hook lifecycles.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/plugin.ts
@src/types/openclaw.ts
@src/memory/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test gateway start/stop lifecycle</name>
  <files>src/__tests__/gateway-lifecycle.test.ts</files>
  <action>
Create `src/__tests__/gateway-lifecycle.test.ts`:

**Mock strategy:** vi.mock the factory modules that gateway_start calls internally. This avoids needing real Redis/SQLite/embedding models.

vi.mock these modules:
- `../store/factory.js` — createStore returns a mock MemoryStore with `backend: "sqlite"`, `close: vi.fn()`, and stub methods
- `../embedding/factory.js` — createEmbeddingProvider returns mock with `modelName: "test"`, `dimensions: 384`, `embed: vi.fn()` returning a 384-dim zero vector, `close: vi.fn()`
- `../embedding/validation.js` — validateEmbeddingDimensions returns `{ ok: true }`
- `../llm/factory.js` — createLLMProvider returns mock with `modelName: "test"`, `generate: vi.fn()`
- `../sync/index.js` — createEventBus returns mock EventBus with `subscribe: vi.fn()`, `close: vi.fn()`; FilesystemSync mock with `start: vi.fn()`, `initialSync: vi.fn()`, `stop: vi.fn()`
- `../access/index.js` — createTransactiveIndex returns mock with `recordWrite: vi.fn()`, `clear: vi.fn()`, `getExpertsForDomain: vi.fn()`
- `../daemon/index.js` — startSweepScheduler returns a cleanup vi.fn(), startConsolidationScheduler returns a cleanup vi.fn()
- `../pipeline/write.js` — write returns mock WriteResult
- `../pipeline/read.js` — search returns empty array

**Setup pattern:** Each test creates a fresh mock API (inline or via simple factory — do NOT import from `./mock-api.js` since that would create cross-plan dependency; duplicate a lightweight mock inline). Call registerPlugin(api) to capture hooks, then invoke hooks by name.

**Test suite:**
- "gateway_start initializes all subsystems": invoke the captured gateway_start handler with `{ port: 3000 }` event and `{}` context. Verify: createStore called, createEmbeddingProvider called, validateEmbeddingDimensions called, createLLMProvider called, createEventBus called, startSweepScheduler called, startConsolidationScheduler called. Verify logger.info called with "[muma-mem] Ready."
- "gateway_start throws on embedding dimension mismatch": mock validateEmbeddingDimensions to return `{ ok: false, error: "Dimension mismatch" }`, invoke gateway_start, expect it to throw
- "gateway_stop cleans up all resources": first run gateway_start (to initialize state), then invoke gateway_stop with `{}` event and `{}` context. Verify: store.close called, embeddingProvider.close called, eventBus.close called, sweep cleanup fn called, consolidation cleanup fn called, filesystemSync.stop called. Verify logger.info called with "[muma-mem] Shutdown complete."
- "gateway_stop is safe when called without gateway_start": invoke gateway_stop without prior gateway_start — should not throw (module-level state is all null, gateway_stop checks for nulls)

Use `beforeEach` to reset all vi.mock implementations and clear module state. Since Vitest isolates modules per file, plugin.ts module-level state starts fresh for this file.
  </action>
  <verify>pnpm test -- --run src/__tests__/gateway-lifecycle.test.ts passes all tests</verify>
  <done>Gateway lifecycle tests verify: start initializes all subsystems, dimension mismatch throws, stop cleans everything, stop is safe without prior start.</done>
</task>

<task type="auto">
  <name>Task 2: Test session hook lifecycle</name>
  <files>src/__tests__/session-lifecycle.test.ts</files>
  <action>
Create `src/__tests__/session-lifecycle.test.ts`:

**Same mock strategy** as Task 1 — vi.mock all factory modules. Duplicate the lightweight inline mock API factory (do NOT import from mock-api.ts).

**Setup:** In beforeAll or beforeEach, call registerPlugin(api) and invoke gateway_start to initialize module state (store, embedding, etc.). This establishes the baseline state that session hooks expect.

**Test suite:**

1. "session_start creates WorkingMemory and maps sessionKey→sessionId":
   - Invoke session_start with event `{ sessionId: "sess-1" }` and ctx `{ sessionId: "sess-1", sessionKey: "telegram:123:agent1" }`
   - Import `getWorkingMemory` from plugin.ts
   - Verify `getWorkingMemory("sess-1")` returns a WorkingMemory instance (not null)

2. "session_start skips when sessionId is missing":
   - Invoke session_start with event `{ sessionId: "sess-2" }` and ctx `{}` (no sessionId)
   - Verify getWorkingMemory("sess-2") returns null

3. "before_agent_start returns prependContext with memories":
   - First trigger session_start for sess-1
   - Mock the `search` function (from pipeline/read.js) to return a result with note content "test memory"
   - Invoke before_agent_start with event `{ prompt: "hello" }` and ctx `{ sessionId: "sess-1", sessionKey: "telegram:123:agent1", agentId: "agent1" }`
   - Verify result has `prependContext` containing "test memory"

4. "before_agent_start returns undefined when no memories found":
   - Mock search to return empty array
   - Invoke before_agent_start with event `{ prompt: "hi" }` and ctx `{ agentId: "agent1", sessionKey: "test:user" }`
   - Verify result is undefined (no memories to inject)

5. "after_tool_call captures to L1 via sessionKeyToId lookup":
   - First trigger session_start for sess-1 (establishes sessionKey→sessionId mapping)
   - Mock embeddingProvider.embed to return a test vector
   - Invoke after_tool_call with event `{ toolName: "test_tool", params: {}, result: "x".repeat(60) }` and ctx `{ sessionKey: "telegram:123:agent1", agentId: "agent1" }`
   - Verify getWorkingMemory("sess-1") has size > 0 (item was added to L1)

6. "before_compaction promotes L1 without clearing":
   - Ensure sess-1 has L1 items (from test 5 or add manually)
   - Mock write (pipeline) to resolve
   - Invoke before_compaction with event `{ messageCount: 50 }` and ctx `{ sessionId: "sess-1" }`
   - Verify write was called (promotion happened)
   - Verify getWorkingMemory("sess-1") is NOT null (session continues — L1 not cleared)

7. "before_reset promotes and clears L1":
   - Ensure session exists with L1 items
   - Invoke before_reset with event `{ reason: "user_request" }` and ctx `{ sessionId: "sess-1", sessionKey: "telegram:123:agent1" }`
   - Verify write was called (promotion)
   - Verify getWorkingMemory("sess-1") is null (session cleaned up)

8. "session_end promotes and cleans up":
   - Create a new session (session_start), add an L1 item
   - Invoke session_end with event `{ sessionId: "sess-2", messageCount: 10 }` and ctx `{ agentId: "agent1", sessionId: "sess-2" }`
   - Verify getWorkingMemory("sess-2") is null (cleaned up)

9. "message_received writes to L2 for messages >= 20 chars":
   - Mock write to resolve
   - Invoke message_received with event `{ from: "user", content: "This is a meaningful message that should be captured" }` and ctx `{ channelId: "telegram", accountId: "123" }`
   - Verify write was called with content matching the message

10. "message_received skips short messages":
    - Invoke message_received with event `{ from: "user", content: "ok" }` and ctx `{ channelId: "telegram" }`
    - Verify write was NOT called

Note: Tests 1-8 should be ordered to build on session state where practical, but each test should be independently understandable. Use a fresh session setup in beforeEach where possible to avoid test coupling.

**Important:** The module-level `sessions` Map and `sessionKeyToId` Map in plugin.ts are internal state. Use `getWorkingMemory()` (the exported accessor) to verify session state. For sessionKeyToId, verify indirectly through after_tool_call behavior (L1 capture succeeds = mapping exists).
  </action>
  <verify>pnpm test -- --run src/__tests__/session-lifecycle.test.ts passes all tests</verify>
  <done>Session lifecycle tests verify: session creation, sessionKey→sessionId mapping, context injection, L1 capture via reverse lookup, before_compaction promotes without clearing, before_reset promotes and clears, session_end cleanup, message_received episodic capture with length threshold.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm test -- --run src/__tests__/gateway-lifecycle.test.ts` passes
- [ ] `pnpm test -- --run src/__tests__/session-lifecycle.test.ts` passes
- [ ] `pnpm run typecheck` passes (no TS errors in test files)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Gateway lifecycle: start initializes, dimension mismatch throws, stop cleans up, stop safe without start
- Session lifecycle: session_start creates WM + maps sessionKey, before_agent_start injects context, after_tool_call L1 capture, before_compaction promotes without clear, before_reset promotes and clears, session_end cleanup, message_received threshold
  </success_criteria>

<output>
After completion, create `.planning/phases/11-integration-tests/11-02-SUMMARY.md`
</output>
