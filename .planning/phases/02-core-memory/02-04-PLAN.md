---
phase: 02-core-memory
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [src/pipeline/link.ts, src/pipeline/evolve.ts]
autonomous: true
---

<objective>
Implement the Link and Evolve steps that provide Zettelkasten-style note linking and memory evolution.

Purpose: New memories auto-link to related existing memories (LINK-01, LINK-03, LINK-05) and linked notes evolve their context when new related memories arrive (LINK-04, PIPE-05, PIPE-06). Links are bidirectional and stored as JSON adjacency lists.
Output: link() and evolve() step functions for the write pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/note.ts
@src/types/store.ts
@src/llm/provider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Link step — bidirectional note linking</name>
  <files>src/pipeline/link.ts</files>
  <action>
**PIPE-05, LINK-01, LINK-03, LINK-05: Auto-link new memory to related existing memories**

Export:
```typescript
export interface LinkResult {
  linkedNoteIds: string[];     // IDs of notes that were linked to
}

export async function link(
  note: Note,
  store: MemoryStore,
  options?: { maxLinks?: number; minScore?: number },
): Promise<LinkResult>
```

Implementation:
1. Search for similar notes using the note's embedding:
   - `store.search({ query: note.embedding, userId: note.user_id, topK: options?.maxLinks ?? 5, minScore: options?.minScore ?? 0.5 })`
   - Filter out the note itself from results (by ID)
2. For each similar note above threshold:
   a. Add similar note's ID to the new note's links array (if not already present)
   b. Add the new note's ID to the similar note's links array (bidirectional — LINK-03)
   c. Update the similar note via store.update() to persist the new link
3. Update the new note via store.update() with the updated links array
4. Return the list of linked note IDs

Key design decisions:
- Links are stored as string[] (JSON adjacency list) in the note.links field (LINK-05)
- Bidirectional: if A links to B, B must also link to A (LINK-03)
- Use a similarity threshold (default 0.5) to avoid linking unrelated notes
- Cap at maxLinks (default 5) to prevent over-linking
- Do NOT use LLM for link decisions — use vector similarity only (LLM would be too slow and expensive at write time; Phase 3 activation scoring will improve relevance)
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>link() creates bidirectional links between a new note and similar existing notes based on vector similarity</done>
</task>

<task type="auto">
  <name>Task 2: Implement Evolve step — update linked notes' context</name>
  <files>src/pipeline/evolve.ts</files>
  <action>
**PIPE-06, LINK-04: Update linked notes' context when new related memory arrives**

Export:
```typescript
export interface EvolveResult {
  updatedNoteIds: string[];    // IDs of notes whose context was updated
}

export async function evolve(
  note: Note,
  linkedNoteIds: string[],
  store: MemoryStore,
  llm: LLMProvider,
): Promise<EvolveResult>
```

Implementation:
1. If linkedNoteIds is empty, return { updatedNoteIds: [] }
2. Fetch each linked note via store.read(id, note.user_id)
3. For each linked note that exists:
   - Call llm.generateJSON() with a prompt containing:
     - The linked note's current content, context, keywords, tags
     - The new note's content, context, keywords
     - Ask: "Given this new related memory, should the existing note's context be updated? If yes, provide the updated context string and any new tags to add. Respond with JSON: { shouldUpdate: boolean, updatedContext?: string, newTags?: string[] }"
   - If shouldUpdate is true:
     - Update the linked note via store.update() with new context and merged tags
     - Add to updatedNoteIds
4. Return { updatedNoteIds }

Key design decisions:
- Evolve runs AFTER link step (needs linked note IDs)
- Only update context and tags — do NOT change content (that would alter the original memory)
- Batch the LLM call: instead of one LLM call per linked note, build a single prompt with ALL linked notes and ask for a batch response (array of updates). This reduces LLM calls from N to 1.
  - Prompt: "Here are N existing memories that are linked to a new memory. For each, determine if its context should be updated..."
  - Response: `{ updates: [{ noteId, shouldUpdate, updatedContext?, newTags? }] }`
- If LLM returns invalid response, skip evolution (no data loss — context stays as-is)
- Cap at 5 linked notes per evolve call to bound LLM token usage
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>evolve() updates linked notes' context and tags when new related memory arrives, using a single batched LLM call</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds
- [ ] link() creates bidirectional links using vector similarity
- [ ] link() caps links and uses similarity threshold
- [ ] evolve() batches LLM call for efficiency
- [ ] evolve() only updates context/tags, never content
- [ ] Both functions take store/llm as parameters (no global state)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Links are bidirectional (LINK-03)
- Links stored as JSON adjacency list in note.links (LINK-05)
- Auto-linking at write time works (LINK-01)
- Linked notes evolve context on new related memory (LINK-04)
- No unnecessary LLM calls (similarity-based linking, batched evolution)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-core-memory/02-04-SUMMARY.md`
</output>
