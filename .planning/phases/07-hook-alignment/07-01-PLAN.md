---
phase: 07-hook-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/plugin.ts]
autonomous: true
---

<objective>
Rewrite all 6 hook handlers in src/plugin.ts to use correct OpenClaw (event, ctx) two-arg signatures, fix field access patterns, and fix return shapes.

Purpose: MUMA-Mem's hooks were built against speculative API shapes (all typed as `any` with wrong field access). The actual OpenClaw SDK passes two arguments (event, ctx) with different field locations. This phase fixes all hooks to match the real SDK.

Output: All 6 hooks properly typed and using correct event/ctx field access patterns. Return shapes match OpenClaw expectations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/INTEGRATION-SPEC.md
@.planning/phases/06-integration-types/06-01-SUMMARY.md

@src/plugin.ts
@src/types/openclaw.ts
@src/utils/deriveUserId.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix critical hooks (before_agent_start, message_received, after_tool_call)</name>
  <files>src/plugin.ts</files>
  <action>
  Add imports at top of src/plugin.ts:
  - Import OpenClaw hook types from `./types/openclaw.js`: PluginHookBeforeAgentStartEvent, PluginHookAgentContext, PluginHookBeforeAgentStartResult, PluginHookMessageReceivedEvent, PluginHookMessageReceivedContext, PluginHookAfterToolCallEvent, PluginHookAfterToolCallContext
  - Import `deriveUserId` and `deriveUserIdFromMessageCtx` from `./utils/index.js`

  **before_agent_start hook (~line 171):**
  - Change signature from `async (event: any)` to `async (event: PluginHookBeforeAgentStartEvent, ctx: PluginHookAgentContext)`
  - Replace `event.sessionId` with `ctx.sessionId`
  - Replace `event.agentId` with `ctx.agentId`
  - Replace `event.userId` with `deriveUserId(ctx.sessionKey)` — userId never existed on event/ctx
  - Replace `if (!userId || !agentId) return;` with `if (!agentId) return;` — userId from deriveUserId always returns a string ("default" fallback)
  - Replace `event.lastMessage || event.systemPrompt || ""` with `event.prompt || ""`
  - Remove the broken `event.addContext()` / `event.memoryContext` fallback block (lines 219-223)
  - Change return from `{ context: formatted }` to `{ prependContext: formatted }` to match PluginHookBeforeAgentStartResult

  **message_received hook (~line 275):**
  - Change signature from `async (event: any)` to `async (event: PluginHookMessageReceivedEvent, ctx: PluginHookMessageReceivedContext)`
  - Remove `if (event.role !== "user") return;` — there's no `role` field; all message_received events ARE user messages
  - Keep the length guard: `if (!event.content || event.content.length < 20) return;`
  - Derive userId: `const userId = deriveUserIdFromMessageCtx(ctx);`
  - **Remove the entire L1 working memory block** (the `if (event.sessionId && embeddingProvider)` block) — message_received context has NO sessionId or agentId, so L1 capture is impossible in this hook. L1 capture will be handled in Phase 10 via session_start/before_compaction hooks.
  - Fix L2 write: use `userId` from derivation above, use `"unknown"` for agentId (not available in this ctx)

  **after_tool_call hook (~line 312):**
  - Change signature from `async (event: any)` to `async (event: PluginHookAfterToolCallEvent, ctx: PluginHookAfterToolCallContext)`
  - Fix result type: `event.result` is `unknown`, not necessarily `string`. Convert: `const resultStr = typeof event.result === "string" ? event.result : event.result != null ? JSON.stringify(event.result) : "";`
  - Add length guard on resultStr instead of event.result: `if (!resultStr || resultStr.length < 50) return;`
  - Use `resultStr` in content construction (already truncated to 500 chars)
  - Derive userId: `const userId = deriveUserId(ctx.sessionKey);`
  - Get agentId: `const agentId = ctx.agentId ?? "unknown";`
  - **Remove the L1 working memory block** — after_tool_call ctx has sessionKey but not sessionId. The sessions map is keyed by sessionId, so L1 lookup would fail. L1 capture for tool calls will be addressed in Phase 10.
  - Fix L2 write: use derived `userId` and `agentId`
  </action>
  <verify>npx tsc --noEmit passes with no errors</verify>
  <done>Three critical hooks use correct (event, ctx) signatures with proper field access. before_agent_start returns { prependContext }. No references to non-existent event fields (userId, role, sessionId on wrong arg, lastMessage).</done>
</task>

<task type="auto">
  <name>Task 2: Fix minor hooks (session_end, gateway_start, gateway_stop)</name>
  <files>src/plugin.ts</files>
  <action>
  Add remaining type imports (if not already imported): PluginHookSessionEndEvent, PluginHookSessionEndContext, PluginHookGatewayStartEvent, PluginHookGatewayStopEvent, PluginHookGatewayContext

  **session_end hook (~line 232):**
  - Change signature from `async (event: any)` to `async (event: PluginHookSessionEndEvent, ctx: PluginHookSessionEndContext)`
  - `event.sessionId` is correct (exists on event) — keep as-is
  - Add `const agentId = ctx.agentId ?? "unknown";` for promoted items
  - Add `const userId = deriveUserId(undefined);` — session_end ctx has no sessionKey. Use "default" as fallback. This is acceptable because promoted items already have userId set from when they were added to L1.
  - In the promoted items loop, the `item.userId` and `item.agentId` from the WorkingMemory items are already set correctly from when they were captured. No change needed in the write() calls — they already use `item.userId` and `item.agentId`.

  **gateway_start hook (~line 95):**
  - Change signature from `async ()` to `async (_event: PluginHookGatewayStartEvent, _ctx: PluginHookGatewayContext)`
  - Body unchanged — underscore prefix since args are unused

  **gateway_stop hook (~line 348):**
  - Change signature from `async ()` to `async (_event: PluginHookGatewayStopEvent, _ctx: PluginHookGatewayContext)`
  - Body unchanged — underscore prefix since args are unused

  **Also update the `registerPlugin` function signature:**
  - Change `api: any` to `api: OpenClawPluginApi` (import from `./types/openclaw.js`)
  - This gives type safety on api.on(), api.logger, api.pluginConfig, etc.
  </action>
  <verify>npx tsc --noEmit passes with no errors</verify>
  <done>All 6 hooks use typed (event, ctx) two-arg signatures. registerPlugin accepts typed OpenClawPluginApi. No `any` types remain on hook handlers or api parameter.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes — no TypeScript errors
- [ ] All 6 hooks use `(event, ctx)` two-arg signatures with proper types
- [ ] No references to non-existent fields (event.userId, event.role, event.sessionId on wrong hook, event.lastMessage)
- [ ] before_agent_start returns `{ prependContext }` not `{ context }`
- [ ] registerPlugin parameter typed as `OpenClawPluginApi`
- [ ] deriveUserId/deriveUserIdFromMessageCtx imported and used where userId is needed
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- All hook signatures match OpenClaw SDK expectations from INTEGRATION-SPEC.md Section 3
- Plugin API parameter properly typed
  </success_criteria>

<output>
After completion, create `.planning/phases/07-hook-alignment/07-01-SUMMARY.md`
</output>
