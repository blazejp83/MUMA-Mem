---
phase: 04-multi-agent
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/sync/events.ts, src/sync/index.ts, src/plugin.ts, src/pipeline/write.ts]
autonomous: true
---

<objective>
Implement cross-agent event bus for memory write notifications with Redis pub/sub and SQLite polling fallback.

Purpose: Enables multi-agent coordination by notifying all connected agents when memories are created, updated, or deleted. Provides the infrastructure for cache invalidation (AGENT-03) and filesystem sync (Plan 04).
Output: EventBus abstraction with Redis and SQLite backends, wired into write pipeline and plugin lifecycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/plugin.ts
@src/pipeline/write.ts
@src/store/redis.ts
@src/types/store.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventBus abstraction with Redis and SQLite backends</name>
  <files>src/sync/events.ts, src/sync/index.ts</files>
  <action>
    Create src/sync/events.ts with:

    1. Types:
       ```
       type MemoryEventType = "memory:write" | "memory:update" | "memory:delete"
       interface MemoryEvent {
         type: MemoryEventType
         noteId: string
         userId: string
         agentId: string
         domain: string
         timestamp: string  // ISO 8601
       }
       type MemoryEventHandler = (event: MemoryEvent) => void
       interface EventBus {
         emit(event: MemoryEvent): Promise<void>
         subscribe(handler: MemoryEventHandler): () => void  // returns unsubscribe fn
         close(): Promise<void>
       }
       ```

    2. RedisEventBus class:
       - Constructor takes RedisClientType (the existing connected client from store) and channel name (default: "muma:events")
       - Create a DUPLICATE client for subscriber (Redis requires separate connections for pub/sub)
       - emit(): PUBLISH serialized JSON event to channel
       - subscribe(): SUBSCRIBE to channel, parse JSON, call handler. Return unsubscribe function.
       - close(): UNSUBSCRIBE + quit duplicate client
       - IMPORTANT: The subscriber client must be connected before subscribing. Call `.connect()` in an async init method, not constructor.

    3. SQLiteEventBus class:
       - Constructor takes the SQLite db path from config
       - On init, CREATE TABLE IF NOT EXISTS muma_events (id INTEGER PRIMARY KEY AUTOINCREMENT, payload TEXT NOT NULL, created_at TEXT NOT NULL DEFAULT (datetime('now')))
       - emit(): INSERT INTO muma_events
       - subscribe(): Start a polling interval (default 2000ms). SELECT * FROM muma_events WHERE id > lastSeenId ORDER BY id. Update lastSeenId. Call handler for each.
       - close(): clearInterval, no DB close (shared with store)
       - Use better-sqlite3 synchronous API (already a dependency)

    4. Factory function:
       ```
       async function createEventBus(storeBackend: "redis" | "sqlite", config: MumaConfig, redisClient?: RedisClientType): Promise<EventBus>
       ```
       - If redis: create RedisEventBus with duplicate of provided client
       - If sqlite: create SQLiteEventBus with config.sqlite.path

    Create src/sync/index.ts barrel exporting all types and createEventBus.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>EventBus interface + Redis/SQLite implementations compile. Factory creates correct backend.</done>
</task>

<task type="auto">
  <name>Task 2: Wire event bus into write pipeline and plugin lifecycle</name>
  <files>src/plugin.ts, src/pipeline/write.ts</files>
  <action>
    1. In src/plugin.ts:
       - Add module-level: `let eventBus: EventBus | null = null;`
       - Add accessor: `export function getEventBus(): EventBus | null { return eventBus; }`
       - In gateway_start (after store creation, before tools registration):
         ```
         // For Redis: pass the redis client from store for duplication
         // The store exposes .backend but not the client directly.
         // Solution: createEventBus takes store.backend and config. For Redis, it creates its own client from config.redis.url.
         eventBus = await createEventBus(store.backend, config);
         api.logger.info(`[muma-mem] Event bus: ${store.backend}`);
         ```
       - In gateway_stop (before store.close()):
         ```
         if (eventBus) { await eventBus.close(); eventBus = null; }
         ```
       - Export getEventBus from the module

    2. In src/pipeline/write.ts:
       - Import getEventBus from plugin.ts
       - After each successful write operation (ADD, UPDATE, DELETE), emit event:
         ```
         const bus = getEventBus();
         if (bus) {
           void bus.emit({
             type: operation === "ADD" ? "memory:write" : operation === "UPDATE" ? "memory:update" : "memory:delete",
             noteId: note?.id ?? decision.targetNoteId ?? "",
             userId: options.userId,
             agentId: options.agentId,
             domain: note?.domain ?? "",
             timestamp: new Date().toISOString(),
           }).catch(() => {}); // Fire-and-forget, don't block write pipeline
         }
         ```
       - Emit AFTER the store operation completes (not before)
       - Use void + .catch() pattern (same as access tracking in read.ts) — event emission must not slow down or fail the write pipeline

    3. Update src/index.ts to re-export event bus types and getEventBus accessor.

    NOTE: For RedisEventBus, do NOT reuse the store's client. Create a fresh client from config.redis.url. The subscriber needs its own connection. The publisher can share, but for simplicity create a dedicated pub client too (one for pub, one for sub — two new connections).
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>Event bus initializes on gateway_start, closes on gateway_stop. Write pipeline emits events on ADD/UPDATE/DELETE. Events are fire-and-forget (non-blocking).</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] EventBus type exported from src/sync/index.ts
- [ ] getEventBus() exported from src/plugin.ts and src/index.ts
- [ ] Write pipeline emits events for ADD, UPDATE, DELETE operations
- [ ] Event emission is fire-and-forget (uses void + .catch pattern)
- [ ] gateway_start creates event bus, gateway_stop closes it
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Event bus has both Redis pub/sub and SQLite polling implementations
- Write pipeline emits non-blocking events
- Plugin lifecycle manages event bus init/teardown
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-agent/04-02-SUMMARY.md`
</output>
