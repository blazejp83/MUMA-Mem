---
phase: 04-multi-agent
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [src/access/visibility.ts, src/access/__tests__/visibility.test.ts, src/access/index.ts]
autonomous: true
---

<objective>
Implement access control logic for the two-axis (domain + visibility) memory access model with TDD.

Purpose: Pure functions that determine whether an agent can see a given note, based on domain matching (longest-prefix), visibility level, and per-agent profiles. These are the building blocks for the visibility gate in the read pipeline and domain rule application in the write pipeline.
Output: Tested access control module at src/access/ with full test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/note.ts
@src/config.ts
</context>

<feature>
  <name>Access Control — Visibility, Domain Matching, Agent Profiles</name>
  <files>src/access/visibility.ts, src/access/__tests__/visibility.test.ts, src/access/index.ts</files>
  <behavior>
    Four exported functions:

    1. `resolveAgentProfile(agentId: string, config: MumaConfig): AgentProfile`
       - Returns config.agentMemory[agentId] if exists
       - Falls back to config.defaultAgentMemory
       - AgentProfile: { domains: string[], canSeePrivate: boolean }

    2. `matchDomainPrefix(noteDomain: string, agentDomains: string[]): boolean`
       - Longest-prefix matching: "business/sales" matches agent domain "business" (prefix)
       - Exact match: "business/sales" matches "business/sales"
       - Wildcard: "*" matches everything
       - No match: "business/sales" does NOT match "personal"
       - Empty domain "": matches only "" or "*"
       - Cases:
         ("business/sales", ["business"]) → true
         ("business/sales", ["business/sales"]) → true
         ("business/sales", ["business/marketing"]) → false
         ("business/sales", ["personal"]) → false
         ("business/sales", ["*"]) → true
         ("business/sales", []) → false
         ("general", ["*"]) → true
         ("business/sales/q1", ["business/sales"]) → true (nested prefix)
         ("business", ["business/sales"]) → false (child doesn't match parent request)

    3. `applyDomainRule(noteDomain: string, domainRules: Record<string, Visibility>, defaultVisibility: Visibility): Visibility`
       - Finds the longest matching prefix in domainRules keys
       - Returns that rule's visibility
       - Falls back to defaultVisibility if no rule matches
       - Cases:
         ("business/sales", {"business": "scoped"}, "open") → "scoped"
         ("business/sales", {"business/sales": "private", "business": "scoped"}, "open") → "private" (longest match wins)
         ("personal/health", {"business": "scoped"}, "open") → "open" (no match, default)
         ("general", {}, "scoped") → "scoped" (empty rules, default)

    4. `canAgentSeeNote(note: {visibility, domain, created_by}, agentId: string, profile: AgentProfile): boolean`
       - Visibility rules:
         - "open": any agent can see it → always true (if domain matches)
         - "scoped": agents in same domain can see it → matchDomainPrefix(note.domain, profile.domains)
         - "private": only the owning agent OR agents with canSeePrivate → note.created_by === agentId || profile.canSeePrivate
         - "user-only": no agent can see it → always false
       - Domain check: For "open" and "scoped", agent must have domain access via matchDomainPrefix
       - Cases:
         (open note, any profile with domain match) → true
         (open note, profile WITHOUT domain match) → false
         (scoped note, same-domain profile) → true
         (scoped note, different-domain profile) → false
         (private note, owning agent) → true
         (private note, canSeePrivate=true agent) → true
         (private note, other agent) → false
         (user-only note, any agent) → false
  </behavior>
  <implementation>
    Pure functions using Note type's visibility/domain/created_by fields and MumaConfig's agentMemory/defaultAgentMemory/visibility schemas.

    For matchDomainPrefix: sort agentDomains by length descending, check if noteDomain === domain || noteDomain.startsWith(domain + "/") || domain === "*". Return true on first match.

    For applyDomainRule: collect matching keys from domainRules where noteDomain === key || noteDomain.startsWith(key + "/"), pick the longest key, return its value. Fall back to defaultVisibility.

    Export AgentProfile interface from the module. Create src/access/index.ts barrel re-exporting everything from visibility.ts.
  </implementation>
</feature>

<verification>
npx vitest run src/access/__tests__/visibility.test.ts
</verification>

<success_criteria>
- All test cases from <behavior> pass
- 4 functions exported: resolveAgentProfile, matchDomainPrefix, applyDomainRule, canAgentSeeNote
- AgentProfile type exported
- src/access/index.ts barrel export created
- RED-GREEN-REFACTOR commits present
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-agent/04-01-SUMMARY.md`
</output>
