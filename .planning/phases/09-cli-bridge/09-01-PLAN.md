---
phase: 09-cli-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/openclaw.ts, src/cli/openclaw.ts, src/plugin.ts]
autonomous: true
---

<objective>
Add Commander-based CLI registration for OpenClaw integration using api.registerCli(), wrapping existing CLI command logic under a `memory` subcommand namespace.

Purpose: Enable MUMA-Mem CLI commands (stats, export, consolidate, conflicts) to work inside OpenClaw's CLI framework while keeping the standalone `muma` binary unchanged (Option A: dual CLI).
Output: New `src/cli/openclaw.ts` registrar, updated plugin registration to include CLI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/INTEGRATION-SPEC.md (Section 6: CLI Integration)
@.planning/phases/06-integration-types/06-01-SUMMARY.md

@src/types/openclaw.ts
@src/cli/index.ts
@src/cli/stats.ts
@src/cli/export.ts
@src/cli/consolidate.ts
@src/cli/conflicts.ts
@src/plugin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenClaw CLI registrar with Commander type</name>
  <files>src/types/openclaw.ts, src/cli/openclaw.ts</files>
  <action>
  **1a. Add minimal Commander type to src/types/openclaw.ts:**

  Add a `CommanderLikeCommand` interface above the existing `OpenClawPluginCliContext` type. This type describes just the Commander.js methods we need (command, description, option, requiredOption, action) — no npm dependency needed since OpenClaw provides Commander at runtime.

  ```typescript
  export type CommanderLikeCommand = {
    command(nameAndArgs: string): CommanderLikeCommand;
    description(str: string): CommanderLikeCommand;
    option(flags: string, description: string): CommanderLikeCommand;
    requiredOption(flags: string, description: string): CommanderLikeCommand;
    action(fn: (...args: any[]) => void | Promise<void>): CommanderLikeCommand;
  };
  ```

  Then update `OpenClawPluginCliContext.program` from `unknown` to `CommanderLikeCommand`.

  **1b. Create src/cli/openclaw.ts:**

  Create a `registerMemoryCli(api: OpenClawPluginApi)` function that calls `api.registerCli()` with a registrar function and `{ commands: ["memory"] }` options.

  The registrar receives `{ program, config, workspaceDir, logger }` from OpenClaw. It should:

  1. Create a `memory` parent command: `program.command("memory").description("MUMA-Mem memory management")`
  2. Register 4 subcommands under it, each with `--user <userId>` as required option:

  **memory stats:**
  - No extra options
  - Action: call `getStore()` from plugin.ts, then call `statsCommand(store, userId)`
  - Wrap in try/catch; if store not initialized, print "Error: MUMA-Mem not initialized. Is the gateway running?" via logger.error

  **memory export:**
  - Extra option: `--output <path>` (optional output file path)
  - Action: call `getStore()`, then `exportCommand(store, userId, opts.output)`

  **memory consolidate:**
  - No extra options
  - Action: call `getStore()` and `getConfig()`, then `consolidateCommand(store, config, userId)`

  **memory conflicts:**
  - Extra option: `--all` (boolean, show resolved conflicts too)
  - Action: call `getStore()`, then `conflictsCommand(store, userId, opts.all)`

  Import the existing command functions from their respective files. Import `getStore` and `getConfig` from `../plugin.js`. Import `OpenClawPluginApi` from `../types/openclaw.js`.

  Do NOT add `commander` as a dependency — the Commander instance is provided by OpenClaw at runtime.
  </action>
  <verify>pnpm run typecheck passes with no errors on the new files</verify>
  <done>src/cli/openclaw.ts exports registerMemoryCli function; OpenClawPluginCliContext.program is properly typed; typecheck passes</done>
</task>

<task type="auto">
  <name>Task 2: Wire CLI registration into registerPlugin</name>
  <files>src/plugin.ts</files>
  <action>
  In `src/plugin.ts`:

  1. Add import: `import { registerMemoryCli } from "./cli/openclaw.js";`
  2. In `registerPlugin()`, after the `registerTools(api)` call and its log line, add:
     ```typescript
     registerMemoryCli(api);
     api.logger.info("[muma-mem] CLI commands registered.");
     ```

  This follows the same pattern as tool registration — CLI is registered at register() time. The actual Commander commands won't run until a user invokes them via the OpenClaw CLI, at which point gateway_start will have already initialized the store and other singletons.
  </action>
  <verify>pnpm run typecheck passes; grep for "registerMemoryCli" in src/plugin.ts confirms it's called</verify>
  <done>registerPlugin() calls registerMemoryCli(api) and logs success; full typecheck passes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes with zero errors
- [ ] `src/cli/openclaw.ts` exports `registerMemoryCli`
- [ ] `src/cli/index.ts` unchanged (standalone CLI preserved)
- [ ] `src/plugin.ts` calls `registerMemoryCli(api)` in `registerPlugin()`
- [ ] `src/types/openclaw.ts` has `CommanderLikeCommand` type and updated `OpenClawPluginCliContext`
- [ ] No new runtime dependencies added to package.json
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- OpenClaw CLI registrar wraps all 4 existing commands (stats, export, consolidate, conflicts)
- Standalone `muma` CLI binary is completely unchanged
- No new npm dependencies added
  </success_criteria>

<output>
After completion, create `.planning/phases/09-cli-bridge/09-01-SUMMARY.md`
</output>
