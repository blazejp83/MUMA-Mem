---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/store/redis.ts
  - package.json
autonomous: true
---

<objective>
Implement the Redis storage backend with CRUD operations, HNSW vector search, and per-user key isolation.

Purpose: STORE-01 (persistence), STORE-02 (Redis as primary backend), STORE-03 (user isolation). Redis provides the full-featured storage path with real-time pub/sub capability (used in later phases).

Output: RedisMemoryStore class implementing the MemoryStore interface with vector search via RediSearch.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@src/types/note.ts
@src/types/store.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement RedisMemoryStore CRUD operations</name>
  <files>src/store/redis.ts, package.json</files>
  <action>
  1. Install: `pnpm add redis` (official node-redis v4+ client with TypeScript support and RediSearch)

  2. **src/store/redis.ts** — RedisMemoryStore class implementing MemoryStore:

  Key design decisions:
  - Key pattern: `{prefix}{userId}:note:{noteId}` (e.g., `muma:user-a:note:uuid-123`)
  - Store notes as Redis HASHes (HSET/HGETALL)
  - Float32Array embedding stored as Buffer (Buffer.from(embedding.buffer))
  - Array fields (keywords, tags, links, access_log) stored as JSON strings
  - Prefix from config.redis.prefix (default "muma:")

  Constructor takes redis config (url, prefix) and embedding dimensions.

  **initialize()**:
  - Connect to Redis using `createClient({ url: config.url })`
  - Create RediSearch vector index if not exists (see Task 2)
  - Set `this._dimensions` from config or null

  **create(noteCreate)**:
  - Generate UUID v4 for id (use `crypto.randomUUID()`)
  - Populate defaults: created_at/updated_at = ISO now, access_count = 0, access_log = [], activation = 0, half_life = 168 (7 days), version = 1, pinned = false, importance = noteCreate.importance ?? 0.5, source = noteCreate.source ?? "experience", confidence = noteCreate.confidence ?? 0.5, visibility = noteCreate.visibility ?? "scoped", domain = noteCreate.domain ?? "", context = noteCreate.context ?? "", keywords = noteCreate.keywords ?? [], tags = noteCreate.tags ?? [], links = noteCreate.links ?? []
  - HSET all fields to `{prefix}{userId}:note:{id}`
  - Track dimensions from first embedding if not set
  - Return full Note object

  **read(id, userId)**:
  - HGETALL `{prefix}{userId}:note:{id}`
  - If empty → return null
  - Deserialize: parse JSON arrays, convert Buffer to Float32Array, parse numbers
  - Return Note

  **update(id, userId, updates)**:
  - Read existing note first
  - If not found → return null
  - Merge updates, bump version, set updated_at
  - If embedding updated, convert to Buffer
  - HSET changed fields
  - Return updated Note

  **delete(id, userId)**:
  - DEL `{prefix}{userId}:note:{id}`
  - Return true if deleted, false if key didn't exist

  **listByUser(userId, options)**:
  - Use SCAN with pattern `{prefix}{userId}:note:*`
  - Paginate with cursor, apply limit/offset
  - HGETALL each key, deserialize
  - Return Note[]

  **countByUser(userId)**:
  - SCAN count matching `{prefix}{userId}:note:*`
  - Or maintain a counter key `{prefix}{userId}:count`

  **close()**:
  - Disconnect Redis client

  **Serialization helpers** (private methods):
  - `serializeNote(note: Note): Record<string, string | Buffer>` — convert Note to Redis HASH fields
  - `deserializeNote(data: Record<string, string>): Note` — convert Redis HASH back to Note

  Use `.js` extensions for all imports. Handle connection errors gracefully with descriptive messages.
  </action>
  <verify>`pnpm run typecheck` passes — RedisMemoryStore compiles with full MemoryStore interface</verify>
  <done>RedisMemoryStore CRUD operations implemented: create, read, update, delete, listByUser, countByUser. Notes stored as Redis HASHes with proper serialization.</done>
</task>

<task type="auto">
  <name>Task 2: Implement vector search and user isolation</name>
  <files>src/store/redis.ts</files>
  <action>
  Add to the existing RedisMemoryStore class:

  **Vector Index Creation** (called from initialize()):
  - Use `client.ft.create()` to create a RediSearch index for vector search
  - Index name: `{prefix}idx` (e.g., `muma:idx`)
  - Schema:
    - `embedding`: VECTOR HNSW with TYPE FLOAT32, DIM from config, DISTANCE_METRIC COSINE
    - `user_id`: TAG (for filtering)
    - `domain`: TAG (for domain boost in later phases)
    - `visibility`: TAG (for visibility gate in later phases)
    - `content`: TEXT (for hybrid search in later phases)
    - `activation`: NUMERIC (for score-based filtering)
    - `pinned`: TAG
  - ON HASH, PREFIX `{prefix}` (matches all user note keys)
  - Wrap in try/catch — if index already exists (ResponseError "Index already exists"), skip silently
  - If dimensions not known yet (no config, no stored vectors), defer index creation until first write

  **search(options)** implementation:
  - Build KNN query: `@user_id:{userId}=>[KNN {topK} @embedding $vec AS score]`
  - The user_id filter ensures STORE-03 (user isolation) — agents can only search their own user's memories
  - Execute with `client.ft.search(indexName, query, { PARAMS: { vec: Buffer.from(queryVector.buffer) }, DIALECT: 2, RETURN: [...all fields], SORTBY: { BY: "score", DIRECTION: "ASC" } })`
  - Parse results: extract documents, deserialize Notes, pair with scores
  - Apply minScore filter if provided
  - Return VectorSearchResult[]

  **Deferred index creation**:
  - If dimensions are unknown at initialize() time, store a flag `_indexCreated = false`
  - On first create() call that includes an embedding, detect dimensions and create the index
  - This handles the case where config doesn't specify dimensions and no vectors exist yet

  **User isolation guarantee**:
  - All CRUD operations include userId in the key path
  - All search operations include @user_id:{userId} filter
  - No operation can access another user's notes

  **Important**: Use the `redis` package's built-in TypeScript types for FT commands:
  ```typescript
  import { createClient, SchemaFieldTypes, VectorAlgorithms } from "redis";
  ```
  </action>
  <verify>
  - `pnpm run typecheck` passes
  - Write a test script (test/redis-smoke.ts) that:
    1. Creates RedisMemoryStore with test config
    2. Initializes (connects, creates index)
    3. Creates a note with a random 384-dim embedding
    4. Searches with same embedding, expects note returned with high score
    5. Deletes the note
    6. Closes connection
    7. Run with: `npx tsx test/redis-smoke.ts` (requires local Redis with RediSearch module)
  - Note: This test requires Redis Stack running locally. If not available, typecheck is sufficient.
  </verify>
  <done>Vector search works via RediSearch FT.SEARCH with HNSW index. User isolation enforced through key prefixing and TAG filter. Deferred index creation handles unknown dimensions.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes with zero errors
- [ ] RedisMemoryStore fully implements MemoryStore interface
- [ ] Key pattern includes userId for isolation
- [ ] Search query includes @user_id filter
- [ ] Index creation handles "already exists" gracefully
- [ ] Serialization round-trips correctly (Note → Redis HASH → Note)
</verification>

<success_criteria>

- All tasks completed
- RedisMemoryStore implements complete MemoryStore interface
- Vector index uses HNSW with COSINE distance
- User isolation at both key and query level
- Deferred index creation handles first-run scenario
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
