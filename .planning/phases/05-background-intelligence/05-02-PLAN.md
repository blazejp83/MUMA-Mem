---
phase: 05-background-intelligence
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/consolidation/cluster.ts
  - src/consolidation/summarize.ts
  - src/consolidation/conflicts.ts
  - src/consolidation/consolidate.ts
  - src/consolidation/index.ts
  - src/types/store.ts
  - src/store/redis.ts
  - src/store/sqlite.ts
autonomous: true
---

<objective>
Build the consolidation engine: cluster related memories, generate summaries, detect conflicts, and resolve compatible ones automatically.

Purpose: Over time, memory stores accumulate redundant and potentially conflicting information. Consolidation distills clusters of related notes into summaries while preserving originals, and surfaces contradictions for user resolution.
Output: Consolidation pipeline that clusters, summarizes, prunes redundant, detects conflicts, and auto-resolves compatible ones.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/store.ts
@src/types/note.ts
@src/store/redis.ts
@src/store/sqlite.ts
@src/llm/provider.ts
@src/pipeline/extract.ts
@src/pipeline/decide.ts
@src/embedding/types.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create clustering and summarization modules</name>
  <files>src/consolidation/cluster.ts, src/consolidation/summarize.ts, src/consolidation/index.ts</files>
  <action>
  **Create src/consolidation/cluster.ts:**

  Export `clusterNotes(notes: Note[], similarityThreshold?: number): NoteCluster[]`
  - Default similarityThreshold = 0.75
  - Algorithm: greedy single-linkage clustering
    1. For each note, compare embedding against all other notes via cosine similarity
    2. Group notes where similarity >= threshold into clusters
    3. Use union-find or simple set merging for transitive grouping (if A~B and B~C, then {A,B,C})
    4. Notes with no similar peers become singleton clusters
  - Return type: `interface NoteCluster { id: string; notes: Note[]; centroid?: Float32Array }`
  - Compute centroid as average of all cluster embeddings (useful for MEMORY.md distillation)
  - Export `cosineSimilarity(a: Float32Array, b: Float32Array): number` as utility

  **Create src/consolidation/summarize.ts:**

  Export `summarizeCluster(cluster: NoteCluster, llm: LLMProvider): Promise<ConsolidationResult>`
  - For singleton clusters (1 note): return as-is, no summarization needed
  - For multi-note clusters: call LLM with all note contents to generate a consolidated summary
  - LLM prompt should:
    - List all note contents
    - Ask for a single consolidated summary that preserves all unique information
    - Ask for a confidence score (0-1) on how well the summary captures the cluster
  - Return type:
    ```typescript
    interface ConsolidationResult {
      clusterId: string;
      summary: string;           // LLM-generated consolidated text
      sourceNoteIds: string[];   // Original note IDs (preserved, not deleted)
      confidence: number;        // LLM confidence in summary quality
      redundantNoteIds: string[]; // Notes fully captured by summary (pruning candidates)
    }
    ```
  - Mark notes as redundant if the LLM indicates they're fully subsumed by the summary
  - CONSOL-05: Never delete originals — only flag them

  **Create src/consolidation/index.ts:**
  Barrel export for cluster, summarize, conflicts, consolidate modules.
  </action>
  <verify>npm run typecheck passes with new modules</verify>
  <done>Clustering groups similar notes, summarization generates LLM summaries for clusters, redundant notes flagged (not deleted)</done>
</task>

<task type="auto">
  <name>Task 2: Create conflict detection, resolution, and consolidation orchestrator</name>
  <files>src/consolidation/conflicts.ts, src/consolidation/consolidate.ts, src/types/store.ts, src/store/redis.ts, src/store/sqlite.ts</files>
  <action>
  **Create src/consolidation/conflicts.ts:**

  Export conflict detection and resolution:

  ```typescript
  type ConflictType = "compatible" | "contradictory" | "subsumes" | "ambiguous";

  interface MemoryConflict {
    id: string;              // UUID
    noteIdA: string;
    noteIdB: string;
    type: ConflictType;
    description: string;     // LLM explanation of the conflict
    resolved: boolean;
    resolution?: string;     // How it was resolved
    detectedAt: string;      // ISO 8601
  }
  ```

  Export `detectConflicts(cluster: NoteCluster, llm: LLMProvider): Promise<MemoryConflict[]>`
  - For clusters with 2+ notes, send pairs to LLM for conflict classification
  - LLM prompt: Given two memories, classify their relationship as one of:
    - compatible: both true, can coexist (e.g., "likes coffee" + "prefers dark roast")
    - contradictory: mutually exclusive (e.g., "lives in NYC" + "lives in SF")
    - subsumes: one fully contains the other (e.g., "has a dog" + "has a golden retriever named Max")
    - ambiguous: unclear relationship, needs human review
  - For efficiency: only check pairs within the same cluster (already semantically related)
  - Use batch LLM calls when possible (send multiple pairs in one prompt)

  Export `resolveConflicts(conflicts: MemoryConflict[]): MemoryConflict[]`
  - Auto-resolve compatible: mark resolved=true, resolution="compatible - both retained"
  - Auto-resolve subsumes: mark resolved=true, resolution="subsumed by {noteId}"
  - Flag contradictory: resolved=false (CONSOL-06: requires user resolution)
  - Flag ambiguous: resolved=false

  **Add conflict storage to MemoryStore interface (src/types/store.ts):**
  Add methods:
  ```typescript
  // Conflict storage (for consolidation)
  saveConflicts(conflicts: MemoryConflict[]): Promise<void>;
  getConflicts(options?: { resolved?: boolean; limit?: number }): Promise<MemoryConflict[]>;
  resolveConflict(conflictId: string, resolution: string): Promise<boolean>;
  ```

  Import MemoryConflict type from consolidation module — BUT to avoid circular deps, define the ConflictType and MemoryConflict types in src/types/note.ts alongside other domain types. Then import from there in both store and consolidation.

  **Redis implementation (src/store/redis.ts):**
  - Store conflicts as JSON in `{prefix}conflicts:{id}` keys
  - Use SCAN for listing, HSET for save, HGET for read

  **SQLite implementation (src/store/sqlite.ts):**
  - Create `conflicts` table: id TEXT PK, note_id_a TEXT, note_id_b TEXT, type TEXT, description TEXT, resolved INTEGER, resolution TEXT, detected_at TEXT
  - Standard INSERT/SELECT/UPDATE operations

  **Create src/consolidation/consolidate.ts:**

  Export `consolidate(userId: string, store: MemoryStore, embedding: EmbeddingProvider, llm: LLMProvider): Promise<ConsolidationReport>`
  - Orchestrator that runs the full pipeline for one user:
    1. Fetch all notes: `store.listByUser(userId, { limit: 1000 })`
    2. Cluster: `clusterNotes(notes)`
    3. For each multi-note cluster:
       a. Summarize: `summarizeCluster(cluster, llm)`
       b. Detect conflicts: `detectConflicts(cluster, llm)`
       c. Resolve conflicts: `resolveConflicts(conflicts)`
    4. Store summary notes: create new notes with tag "consolidated", link to source notes
    5. Save conflicts: `store.saveConflicts(allConflicts)`
    6. Return report: clusters found, summaries created, conflicts detected/resolved

  Return type:
  ```typescript
  interface ConsolidationReport {
    userId: string;
    clustersFound: number;
    summariesCreated: number;
    conflictsDetected: number;
    conflictsAutoResolved: number;
    conflictsNeedingReview: number;
    timestamp: string;
  }
  ```
  </action>
  <verify>npm run typecheck passes with all new modules and store interface extensions</verify>
  <done>Full consolidation pipeline works: cluster → summarize → detect conflicts → resolve → store results. Originals preserved (CONSOL-05). Compatible conflicts auto-resolved (CONSOL-06). Contradictory conflicts flagged for user review.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm run build` succeeds
- [ ] Clustering correctly groups similar notes
- [ ] Summarization produces consolidated text via LLM
- [ ] Conflict detection classifies note pairs
- [ ] Compatible conflicts auto-resolved, contradictory flagged
- [ ] Store interface extended with conflict storage in both backends
- [ ] Original notes never deleted (non-destructive)
</verification>

<success_criteria>
- All tasks completed
- CONSOL-01: Clustering + summarization works
- CONSOL-02: Redundant notes flagged after summarization
- CONSOL-03: Conflict detection with 4 types
- CONSOL-05: Original memories preserved
- CONSOL-06: Compatible auto-resolved, contradictory requires user
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/05-background-intelligence/05-02-SUMMARY.md`
</output>
