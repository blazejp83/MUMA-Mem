---
phase: 04-multi-agent
plan: 04
type: execute
wave: 2
depends_on: ["04-02"]
files_modified: [src/sync/filesystem.ts, src/sync/index.ts, src/plugin.ts]
autonomous: true
---

<objective>
Implement bidirectional filesystem sync between the memory store and ~/clawd/memory/ as human-readable markdown files.

Purpose: Makes memories inspectable and editable via standard file tools. Changes in either direction propagate automatically.
Output: Filesystem serializer/deserializer + bidirectional watcher integrated into plugin lifecycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Depends on Plan 02 output (event bus):
@src/sync/events.ts
@src/sync/index.ts

@src/types/note.ts
@src/plugin.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Note ↔ markdown file serializer/deserializer</name>
  <files>src/sync/filesystem.ts</files>
  <action>
    Create src/sync/filesystem.ts with:

    **File format:** Each note becomes a markdown file at `{baseDir}/{userId}/{noteId}.md`

    ```markdown
    ---
    id: "abc-123"
    domain: "business/sales"
    visibility: "scoped"
    created_by: "sales-agent"
    created_at: "2026-02-15T10:30:00.000Z"
    updated_at: "2026-02-15T10:30:00.000Z"
    tags: ["sales", "quarterly"]
    keywords: ["Q1 forecast", "revenue"]
    importance: 0.7
    confidence: 0.8
    source: "told"
    pinned: false
    links: ["def-456", "ghi-789"]
    activation: 1.5
    half_life: 168
    access_count: 3
    version: 1
    ---

    Q1 sales forecast projects $2.3M revenue based on current pipeline.

    <!-- context: One-sentence semantic summary of this memory -->
    ```

    1. `serializeNoteToMarkdown(note: Note): string`
       - YAML frontmatter with all metadata fields (everything EXCEPT content, context, and embedding)
       - Content as markdown body after frontmatter
       - Context as HTML comment at the end (preserves it without cluttering the readable content)
       - Do NOT serialize embedding (binary data, not human-readable, regenerated on import)
       - Do NOT serialize access_log (too verbose, access_count is sufficient)

    2. `deserializeMarkdownToNoteUpdate(markdown: string): { id: string; userId: string; updates: NoteUpdate & { content?: string } } | null`
       - Parse YAML frontmatter (split on "---" markers)
       - Extract id from frontmatter (required — skip if missing)
       - Extract userId from file path or frontmatter
       - Body after frontmatter → content
       - HTML comment → context
       - Map frontmatter fields to NoteUpdate
       - Return null if parsing fails (malformed file)
       - Use a simple YAML parser: split lines, handle arrays (lines starting with "- "), handle quoted strings, booleans, numbers. Do NOT add a YAML library dependency — the format is simple enough for manual parsing.

    3. `getNotePath(baseDir: string, userId: string, noteId: string): string`
       - Returns `${baseDir}/${userId}/${noteId}.md`

    4. `async writeNoteToFile(note: Note, baseDir: string): Promise<void>`
       - Ensure directory exists: `await fs.mkdir(path.dirname(filePath), { recursive: true })`
       - Write serialized markdown to file

    5. `async deleteNoteFile(userId: string, noteId: string, baseDir: string): Promise<void>`
       - Remove the file if it exists (use fs.unlink with try/catch for ENOENT)

    Use Node.js `fs/promises` and `path` modules only. No external YAML libraries.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
    - serializeNoteToMarkdown produces valid YAML frontmatter + markdown body
    - deserializeMarkdownToNoteUpdate parses it back correctly
    - writeNoteToFile creates directory structure and writes file
    - deleteNoteFile removes the file
  </done>
</task>

<task type="auto">
  <name>Task 2: Bidirectional file watcher + plugin lifecycle integration</name>
  <files>src/sync/filesystem.ts, src/sync/index.ts, src/plugin.ts</files>
  <action>
    **FilesystemSync class (add to src/sync/filesystem.ts):**

    1. Create FilesystemSync class:
       ```
       class FilesystemSync {
         private baseDir: string;
         private watcher: fs.FSWatcher | null = null;
         private unsubscribeEventBus: (() => void) | null = null;
         private debounceTimers: Map<string, NodeJS.Timeout> = new Map();
         // Track files we just wrote to avoid re-importing our own writes
         private recentWrites: Set<string> = new Set();

         constructor(baseDir: string)

         async start(store: MemoryStore, eventBus: EventBus | null): Promise<void>
           // 1. Subscribe to event bus for store→file sync:
           //    On "memory:write" / "memory:update": read note from store, writeNoteToFile
           //    On "memory:delete": deleteNoteFile
           //    Add noteId to recentWrites for 2 seconds to debounce
           //
           // 2. Start fs.watch on baseDir (recursive: true) for file→store sync:
           //    On file change (.md files only):
           //      - Skip if noteId in recentWrites (our own write, not external edit)
           //      - Debounce 500ms (multiple rapid change events for single save)
           //      - Read file, deserializeMarkdownToNoteUpdate
           //      - If valid, store.update(id, userId, updates)
           //      - Re-embed content if content changed (need embeddingProvider)
           //    On file delete:
           //      - Extract noteId from filename
           //      - store.delete(noteId, userId)

         async stop(): Promise<void>
           // Close watcher, unsubscribe from event bus, clear timers

         async initialSync(store: MemoryStore): Promise<void>
           // One-time sync: for each user, list notes from store, write to files
           // Used on startup to populate file tree from existing store data
       }
       ```

    2. **Debounce strategy:**
       - recentWrites: Set of noteIds recently written BY the sync (store→file). Cleared after 2000ms. Prevents re-importing our own writes.
       - debounceTimers: Map of filePath→setTimeout. On fs.watch event, clear previous timer, set new 500ms timer. Prevents multiple events per save.

    3. **File watcher limitations:**
       - fs.watch recursive mode works on macOS and Windows but NOT on Linux for all filesystems. Use try/catch and fall back to non-recursive watching of userId directories if recursive fails.
       - Only watch .md files (ignore .tmp, .swp, etc.)

    **Plugin lifecycle (src/plugin.ts):**

    4. Add module-level: `let filesystemSync: FilesystemSync | null = null;`
    5. In gateway_start (after event bus creation):
       ```
       const syncDir = path.join(os.homedir(), "clawd", "memory");
       filesystemSync = new FilesystemSync(syncDir);
       await filesystemSync.start(store, eventBus);
       await filesystemSync.initialSync(store);
       api.logger.info(`[muma-mem] Filesystem sync: ${syncDir}`);
       ```
    6. In gateway_stop (before event bus close):
       ```
       if (filesystemSync) { await filesystemSync.stop(); filesystemSync = null; }
       ```

    **Update src/sync/index.ts:**
    7. Re-export FilesystemSync class and serialization functions from filesystem.ts.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
    - Store→file: Event bus events trigger file writes/deletes
    - File→store: File changes detected and propagated to store
    - Debounce prevents loops (own writes not re-imported)
    - Plugin lifecycle starts/stops filesystem sync
    - Initial sync populates files from store on startup
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] Note serialization round-trips correctly (serialize → deserialize → same data)
- [ ] FilesystemSync class handles store→file and file→store directions
- [ ] Debounce prevents sync loops
- [ ] Plugin lifecycle integrates filesystem sync (start on gateway_start, stop on gateway_stop)
- [ ] Initial sync exports existing notes to files
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Bidirectional sync between memory store and ~/clawd/memory/
- Human-readable markdown files with YAML frontmatter
- No sync loops (debounce + recentWrites tracking)
- Plugin lifecycle manages sync start/stop
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-agent/04-04-SUMMARY.md`
</output>
