---
phase: 03-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [src/memory/working.ts, src/memory/index.ts, src/plugin.ts, src/index.ts]
autonomous: true
---

<objective>
Implement in-process Working Memory (L1) with activation scoring and wire session lifecycle hooks for context injection and memory promotion.

Purpose: L1 gives agents fast, session-scoped memory that surfaces relevant context automatically at conversation start and promotes important discoveries to persistent storage at session end.
Output: WorkingMemory class, before_agent_start context injection hook, session_end promotion hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-intelligence/03-01-SUMMARY.md

@src/types/note.ts
@src/plugin.ts
@src/pipeline/read.ts
@src/pipeline/write.ts
@src/config.ts
@src/activation/scoring.ts
@src/activation/decay.ts
@src/activation/index.ts
@src/embedding/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkingMemory L1 store</name>
  <files>src/memory/working.ts, src/memory/index.ts</files>
  <action>
    Create an in-process, ephemeral memory store for per-session working memory.

    **src/memory/working.ts:**

    Define `WorkingMemoryItem` interface:
    - id: string (UUID)
    - content: string
    - embedding: Float32Array
    - activation: number (ACT-R score, recomputed on access)
    - accessLog: string[] (ISO timestamps)
    - agentId: string
    - userId: string
    - source: MemorySource
    - createdAt: string (ISO)

    Define `WorkingMemory` class:
    - Constructor takes activation config (decayParameter, contextWeight, noiseStddev) from MumaConfig.activation
    - Private items: Map<string, WorkingMemoryItem>

    Methods:
    - `add(content: string, embedding: Float32Array, meta: { agentId: string, userId: string, source: MemorySource }): string`
      Creates item with id=crypto.randomUUID(), activation=0, accessLog=[now]. Returns id.

    - `query(queryEmbedding: Float32Array, topK?: number): WorkingMemoryItem[]`
      For each item: compute cosine similarity between queryEmbedding and item.embedding.
      Compute total ACT-R activation (base from accessLog + spreading from similarity + noise).
      Record access (push timestamp to accessLog).
      Sort by activation descending. Return top-K (default 5).

      Cosine similarity: dot(a,b) / (norm(a) * norm(b)). Implement as a private helper, not imported from a library.

    - `getTopActivated(threshold: number): WorkingMemoryItem[]`
      Returns all items with activation >= threshold, sorted by activation descending.
      Used by session_end to determine which items to promote.

    - `getContextItems(userId: string, agentId: string, topK?: number): WorkingMemoryItem[]`
      Filter items by userId and agentId, recompute activation for each, sort descending, return top-K (default 10).
      Used by before_agent_start for context injection.

    - `clear(): void`
      Empties the items map. Called after session_end promotion.

    - `size`: number getter for item count.

    **src/memory/index.ts:**
    Barrel export: WorkingMemory, WorkingMemoryItem.

    **Design notes:**
    - NO dependency on MemoryStore interface — L1 is a completely separate in-process structure
    - Uses activation scoring functions from src/activation/ (baseLevelActivation, spreadingActivation, stochasticNoise, totalActivation)
    - Embeddings must be pre-computed by caller (accepts Float32Array, doesn't call embedding provider internally)
    - Thread-safe for single-process Node.js (no mutex needed, JS is single-threaded)
  </action>
  <verify>
    - `pnpm run typecheck` passes
    - `pnpm test` passes
  </verify>
  <done>
    - WorkingMemory class exists with add, query, getTopActivated, getContextItems, clear
    - Uses ACT-R activation scoring for ranking
    - Pure in-process, no external dependencies
    - WM-01 requirement addressed
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire before_agent_start and session_end hooks</name>
  <files>src/plugin.ts, src/index.ts</files>
  <action>
    Wire WorkingMemory into the plugin lifecycle for automatic context injection and memory promotion.

    **Modify src/plugin.ts:**

    1. **Add session state management:**
       - Add module-level `sessions: Map<string, WorkingMemory>` for per-session L1 stores
       - Add helper `getOrCreateSession(sessionId: string, config: MumaConfig): WorkingMemory`
         Creates new WorkingMemory with config.activation params if session doesn't exist.
       - Export `getWorkingMemory(sessionId: string): WorkingMemory | null` accessor.

    2. **Add before_agent_start hook (PLUG-02):**
       Register `api.on("before_agent_start", async (event) => { ... })` inside gateway_start.

       The hook:
       a. Get or create session: getOrCreateSession(event.sessionId, config)
       b. Get L1 context: workingMemory.getContextItems(event.userId, event.agentId, 5)
       c. Get L2 context: search({ query: event.systemPrompt || event.lastMessage || "", userId: event.userId, topK: 10 })
          — Use the last user message or system prompt as the query for relevance.
          — If no query text available, skip L2 retrieval.
       d. Combine L1 + L2 results into a context block.
       e. Return the context to inject via event.addContext() or event.setMemoryContext()
          — Format as markdown: "## Relevant Memories\n\n" + formatted memories
          — Check OpenClaw plugin SDK pattern for how before_agent_start injects context.
          — Since api is typed as `any`, use `return { context: formattedMemories }` or
            whatever the hook return convention is. If unclear, set `event.memoryContext = formatted`.

       **Guard:** If store not initialized or embedding provider not ready, skip silently.

    3. **Add session_end hook (PLUG-03):**
       Register `api.on("session_end", async (event) => { ... })` inside gateway_start.

       The hook:
       a. Get session: sessions.get(event.sessionId)
       b. If no session, return (no L1 data for this session)
       c. Get high-activation items: workingMemory.getTopActivated(config.activation.retrievalThreshold)
       d. For each promoted item, call write() pipeline to persist to L2:
          ```
          await write(item.content, {
            userId: item.userId,
            agentId: item.agentId,
            source: item.source,
          });
          ```
       e. Clear the working memory: workingMemory.clear()
       f. Remove session from sessions map
       g. Log: count of promoted vs discarded items

       **Guard:** If LLM provider not configured, skip promotion (write() requires LLM).
       In this case, just clear and discard all items.

    4. **Wire episodic hooks to also populate L1:**
       Modify existing message_received and after_tool_call hooks to also add to L1 working memory.
       After the existing write() call (or even if write() is skipped due to no LLM):
       - Compute embedding of the content via embeddingProvider.embed()
       - Add to session's working memory: workingMemory.add(content, embedding, meta)
       - This ensures L1 captures everything, even when LLM is unavailable

       **Guard:** Need sessionId from event. If event.sessionId is undefined, skip L1 capture.

    5. **Update gateway_stop** to clear all sessions.

    **Update src/index.ts:**
    - Re-export WorkingMemory, WorkingMemoryItem from src/memory/index.ts
    - Re-export getWorkingMemory from src/plugin.ts
  </action>
  <verify>
    - `pnpm run typecheck` passes
    - `pnpm test` passes
    - Manual review: plugin.ts has before_agent_start and session_end hooks registered
    - Manual review: episodic hooks populate L1 working memory
  </verify>
  <done>
    - before_agent_start injects combined L1+L2 context into agent (PLUG-02)
    - session_end promotes high-activation L1 items to L2 (WM-02, PLUG-03)
    - Low-activation items discarded at session end (WM-03)
    - Episodic hooks populate both L1 and L2
    - Sessions cleaned up on gateway_stop
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes
- [ ] `pnpm test` passes
- [ ] WorkingMemory class exists with activation-based query
- [ ] before_agent_start hook registered and returns context
- [ ] session_end hook promotes/discards L1 items
- [ ] Episodic hooks populate L1 working memory
- [ ] No regression in existing functionality
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- WM-01, WM-02, WM-03, PLUG-02, PLUG-03 requirements addressed
- Working memory lifecycle: create → populate → inject → promote/discard → cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/03-intelligence/03-03-SUMMARY.md`
</output>
