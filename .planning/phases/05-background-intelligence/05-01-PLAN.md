---
phase: 05-background-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/store.ts
  - src/store/redis.ts
  - src/store/sqlite.ts
  - src/daemon/sweep.ts
  - src/daemon/index.ts
  - src/plugin.ts
autonomous: true
---

<objective>
Implement hourly decay sweep daemon that recalculates activation scores system-wide.

Purpose: Memories that aren't accessed naturally decay over time (Ebbinghaus), but the stored `activation` field is only recomputed on search. The sweep ensures activation scores stay current even for unsearched memories, enabling accurate pruning candidate detection.
Output: Background sweep that runs on configurable interval, recalculates activation for all notes, and marks pruning candidates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/store.ts
@src/types/note.ts
@src/store/redis.ts
@src/store/sqlite.ts
@src/activation/scoring.ts
@src/activation/decay.ts
@src/config.ts
@src/plugin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add listAllNotes to MemoryStore interface and implementations</name>
  <files>src/types/store.ts, src/store/redis.ts, src/store/sqlite.ts</files>
  <action>
  Add a new method to the MemoryStore interface for cross-user note iteration:

  ```typescript
  listAllNotes(options?: { limit?: number; offset?: number }): Promise<Note[]>;
  ```

  **Redis implementation (src/store/redis.ts):**
  - Use SCAN to find all `{prefix}*:note:*` keys
  - Paginate using limit/offset over the collected keys
  - Deserialize each note with existing `deserializeNote` helper
  - Important: SCAN is O(N) but cursor-based, so use batch scanning with COUNT hint

  **SQLite implementation (src/store/sqlite.ts):**
  - Simple `SELECT * FROM notes ORDER BY created_at LIMIT ? OFFSET ?`
  - Reuse existing row-to-Note deserialization

  This method is used by the decay sweep to iterate all notes regardless of user_id.
  </action>
  <verify>npm run typecheck passes with the new interface method implemented in both backends</verify>
  <done>MemoryStore interface has listAllNotes, both RedisMemoryStore and SQLiteMemoryStore implement it</done>
</task>

<task type="auto">
  <name>Task 2: Create decay sweep daemon and integrate into plugin lifecycle</name>
  <files>src/daemon/sweep.ts, src/daemon/index.ts, src/plugin.ts</files>
  <action>
  **Create src/daemon/sweep.ts:**

  Export a `runDecaySweep` function that:
  1. Calls `store.listAllNotes()` in pages of 100 (loop with offset until empty batch)
  2. For each note:
     - Skip if `note.pinned === true`
     - Compute `baseLevelActivation(note.access_log, now, config.activation.decayParameter)` â€” this is the base activation without spreading or noise (no query context in background sweep)
     - Compute `computeRetention(note.half_life, elapsedHoursSinceUpdate)` where elapsed = hours since `note.updated_at`
     - New activation = base activation (no spreading/noise in background context)
     - Check `isPruningCandidate(newActivation, config.decay.pruneThreshold, note.pinned)`
     - Update via `store.update(note.id, note.user_id, { activation: newActivation })`
  3. Return stats: `{ processed: number; updated: number; pruningCandidates: number }`
  4. Log summary at end

  **Create src/daemon/index.ts:**
  - Re-export `runDecaySweep`
  - Export `startSweepScheduler(store, config, logger?)` that:
    - Calls `runDecaySweep` immediately on start
    - Sets up `setInterval` using `config.decay.sweepIntervalMinutes * 60 * 1000`
    - Returns a cleanup function `() => void` that calls `clearInterval`
  - Follow the same pattern as SQLiteEventBus polling (setInterval + clearInterval)

  **Update src/plugin.ts:**
  - Import `startSweepScheduler` from `./daemon/index.js`
  - In `gateway_start`, after all initialization, call `startSweepScheduler(store, config, api.logger)`
  - Store the cleanup function in module-level state (e.g., `let sweepCleanup: (() => void) | null = null`)
  - In `gateway_stop`, call `sweepCleanup?.()` before closing other resources
  - Log: `[muma-mem] Decay sweep: every ${config.decay.sweepIntervalMinutes}min`
  </action>
  <verify>npm run typecheck passes; review that sweep integrates cleanly into gateway lifecycle</verify>
  <done>Decay sweep runs on configurable interval, recalculates activation for all notes, respects pinned flag, integrates with gateway start/stop</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm run build` succeeds
- [ ] listAllNotes works in both Redis and SQLite stores
- [ ] Sweep function processes notes and updates activation scores
- [ ] Plugin lifecycle starts/stops sweep correctly
- [ ] Pinned notes are skipped by sweep
</verification>

<success_criteria>
- All tasks completed
- FORGET-05 requirement satisfied: hourly decay sweep recalculates activation scores system-wide
- No errors or warnings introduced
- Sweep is non-blocking and runs in background
</success_criteria>

<output>
After completion, create `.planning/phases/05-background-intelligence/05-01-SUMMARY.md`
</output>
