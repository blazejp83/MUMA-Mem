---
phase: 10-hook-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/openclaw.ts, src/plugin.ts]
autonomous: true
---

<objective>
Add session_start, before_compaction, and before_reset hooks for eager working memory initialization, pre-compaction memory promotion, and pre-reset memory promotion. Enable L1 capture in after_tool_call via a sessionKey→sessionId mapping established at session start.

Purpose: Phase 7 deferred L1 working memory capture from message_received and after_tool_call because their contexts lack sessionId (the sessions map is keyed by sessionId). session_start provides both sessionKey and sessionId, enabling a reverse lookup that unblocks L1 capture in after_tool_call. before_compaction/before_reset ensure memories aren't lost during context compaction or session resets.

Output: 3 new hook handlers in plugin.ts, updated type definitions in openclaw.ts, L1 capture enabled in after_tool_call.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-hook-alignment/07-01-SUMMARY.md

@src/types/openclaw.ts
@src/plugin.ts
@src/memory/working.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type definitions for session_start, before_compaction, and before_reset hooks</name>
  <files>src/types/openclaw.ts</files>
  <action>
Add event and context types for 3 new hooks. Follow the existing pattern in openclaw.ts (separate Event + Context types per hook).

**session_start:**
```
PluginHookSessionStartEvent = { sessionId: string; resumedFrom?: string }
PluginHookSessionStartContext = PluginHookAgentContext  (reuse — has agentId, sessionKey, sessionId, workspaceDir, messageProvider)
```

**before_compaction:**
```
PluginHookBeforeCompactionEvent = { messageCount: number; sessionFile?: string }
PluginHookBeforeCompactionContext = PluginHookAgentContext  (reuse)
```

**before_reset:**
```
PluginHookBeforeResetEvent = { sessionFile?: string; messages?: unknown[]; reason?: string }
PluginHookBeforeResetContext = PluginHookAgentContext  (reuse)
```

Update PluginHookHandlerMap with 3 new entries:
- `session_start: (event: PluginHookSessionStartEvent, ctx: PluginHookAgentContext) => Promise<void> | void`
- `before_compaction: (event: PluginHookBeforeCompactionEvent, ctx: PluginHookAgentContext) => Promise<void> | void`
- `before_reset: (event: PluginHookBeforeResetEvent, ctx: PluginHookAgentContext) => Promise<void> | void`

Export all new types from the file (they are needed by plugin.ts imports).
  </action>
  <verify>npx tsc --noEmit passes with zero errors</verify>
  <done>3 new event types, PluginHookHandlerMap has 9 entries (was 6), all types exported</done>
</task>

<task type="auto">
  <name>Task 2: Add session_start, before_compaction, before_reset handlers and enable L1 capture in after_tool_call</name>
  <files>src/plugin.ts</files>
  <action>
**1. Add module-level sessionKey→sessionId mapping:**

Add `const sessionKeyToId: Map<string, string> = new Map();` alongside the existing `sessions` map.

**2. Import new types** from openclaw.ts:
- PluginHookSessionStartEvent, PluginHookBeforeCompactionEvent, PluginHookBeforeResetEvent

**3. Add session_start handler** (place after gateway_start, before before_agent_start):
```
api.on("session_start", async (event, ctx) => {
  if (!ctx.sessionId) return;
  const config = mumaConfig;
  if (!config) return;

  // Eagerly create WorkingMemory for this session
  getOrCreateSession(ctx.sessionId, config);

  // Establish sessionKey→sessionId mapping for hooks that only have sessionKey
  if (ctx.sessionKey) {
    sessionKeyToId.set(ctx.sessionKey, ctx.sessionId);
  }

  api.logger.info(`[muma-mem] Session started: ${ctx.sessionId}`);
});
```

**4. Add before_compaction handler** (place after session_end):
Pre-compaction: promote high-activation L1 items to L2, but DON'T clear L1 (session continues after compaction).
```
api.on("before_compaction", async (event, ctx) => {
  const sessionId = ctx.sessionId;
  if (!sessionId) return;

  const wm = sessions.get(sessionId);
  if (!wm || wm.size === 0) return;

  const config = mumaConfig;
  if (!config || !llmProvider) return;

  const threshold = config.activation.retrievalThreshold;
  const promoted = wm.getTopActivated(threshold);
  let promotedCount = 0;

  for (const item of promoted) {
    try {
      await write(item.content, {
        userId: item.userId,
        agentId: item.agentId,
        source: item.source,
      });
      promotedCount++;
    } catch {
      // Skip individual promotion failures
    }
  }

  // Do NOT clear L1 — session continues after compaction
  api.logger.info(
    `[muma-mem] Pre-compaction: promoted ${promotedCount} items from L1 to L2 (session ${sessionId}, ${event.messageCount} messages)`
  );
});
```

**5. Add before_reset handler** (place after before_compaction):
Pre-reset: promote ALL L1 items to L2 and clean up (session will restart).
```
api.on("before_reset", async (event, ctx) => {
  const sessionId = ctx.sessionId;
  if (!sessionId) return;

  const wm = sessions.get(sessionId);
  if (!wm || wm.size === 0) {
    // Clean up mapping even if no working memory
    if (ctx.sessionKey) sessionKeyToId.delete(ctx.sessionKey);
    sessions.delete(sessionId);
    return;
  }

  const config = mumaConfig;

  try {
    if (llmProvider && config) {
      const threshold = config.activation.retrievalThreshold;
      const promoted = wm.getTopActivated(threshold);
      let promotedCount = 0;
      const totalCount = wm.size;

      for (const item of promoted) {
        try {
          await write(item.content, {
            userId: item.userId,
            agentId: item.agentId,
            source: item.source,
          });
          promotedCount++;
        } catch {
          // Skip individual failures
        }
      }

      api.logger.info(
        `[muma-mem] Pre-reset: promoted ${promotedCount}/${totalCount} items to L2 (session ${sessionId}, reason: ${event.reason ?? "unknown"})`
      );
    }
  } catch (err) {
    api.logger.warn(`[muma-mem] Pre-reset promotion failed: ${err}`);
  } finally {
    wm.clear();
    sessions.delete(sessionId);
    if (ctx.sessionKey) sessionKeyToId.delete(ctx.sessionKey);
  }
});
```

**6. Enable L1 capture in after_tool_call:**
In the existing after_tool_call handler, AFTER the existing L2 write block, add L1 capture:
```
// L1: Add to working memory if session is active
const sessionId = ctx.sessionKey ? sessionKeyToId.get(ctx.sessionKey) : undefined;
if (sessionId && embeddingProvider && mumaConfig) {
  const wm = sessions.get(sessionId);
  if (wm) {
    try {
      const embedding = await embeddingProvider.embed(content);
      wm.add(content, embedding, { agentId, userId, source: "experience" });
    } catch {
      // Non-blocking — L1 capture is best-effort
    }
  }
}
```

Remove the comment that says "L1 capture for tool calls will be addressed in Phase 10" — it's now addressed.

**7. Clean up sessionKeyToId in gateway_stop and session_end:**
- In gateway_stop: add `sessionKeyToId.clear();` alongside `sessions.clear();`
- In session_end: add `if (ctx.sessionKey) sessionKeyToId.delete(ctx.sessionKey);` in the finally block (but session_end ctx doesn't have sessionKey — check PluginHookSessionEndContext type. If no sessionKey, iterate sessionKeyToId to find the entry for this sessionId and delete it).

Actually, session_end ctx is `{ agentId?: string; sessionId: string }` — no sessionKey. So in session_end's finally block, do a reverse lookup:
```
for (const [key, id] of sessionKeyToId.entries()) {
  if (id === sessionId) {
    sessionKeyToId.delete(key);
    break;
  }
}
```
  </action>
  <verify>npx tsc --noEmit passes with zero errors</verify>
  <done>3 new hook handlers registered (session_start, before_compaction, before_reset), sessionKeyToId mapping enables L1 capture in after_tool_call, all existing hooks still work, TypeScript compiles cleanly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] All 9 hooks registered in plugin.ts (gateway_start, gateway_stop, before_agent_start, session_start, session_end, before_compaction, before_reset, message_received, after_tool_call)
- [ ] PluginHookHandlerMap has 9 entries
- [ ] sessionKeyToId map created and cleaned up in session_end, before_reset, and gateway_stop
- [ ] after_tool_call has L1 capture code (no longer deferred)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- 3 new hooks correctly typed and implemented
- L1 capture enabled in after_tool_call via sessionKey→sessionId mapping
- sessionKeyToId properly cleaned up in all exit paths (session_end, before_reset, gateway_stop)
  </success_criteria>

<output>
After completion, create `.planning/phases/10-hook-extensions/10-01-SUMMARY.md`
</output>
