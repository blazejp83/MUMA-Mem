---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src/store/factory.ts
  - src/index.ts
  - src/plugin.ts
autonomous: true
---

<objective>
Wire everything together: storage auto-detection with Redis→SQLite fallback, OpenClaw plugin entry point with gateway_start/gateway_stop lifecycle hooks, and end-to-end verification.

Purpose: PLUG-01 (register as kind: "memory" plugin), PLUG-05 (gateway lifecycle hooks), STORE-02 (auto-detect Redis, fallback to SQLite). This plan makes the package a functional OpenClaw plugin.

Output: Working plugin that auto-detects storage backend, initializes on gateway_start, cleans up on gateway_stop, and exports for OpenClaw consumption.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
@src/config.ts
@src/types/store.ts
@src/embedding/types.ts
@src/embedding/factory.ts
@src/embedding/validation.ts
@src/store/redis.ts
@src/store/sqlite.ts
@MUMA-Mem-OpenClaw-Integration-Analysis.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement storage factory and plugin entry point with lifecycle hooks</name>
  <files>src/store/factory.ts, src/plugin.ts, src/index.ts</files>
  <action>
  1. **src/store/factory.ts** — Storage auto-detection:

  ```typescript
  import type { MemoryStore } from "../types/store.js";
  import type { MumaConfig } from "../config.js";
  import { RedisMemoryStore } from "./redis.js";
  import { SQLiteMemoryStore } from "./sqlite.js";

  export async function createStore(config: MumaConfig): Promise<MemoryStore> {
    // Try Redis first (full features)
    if (config.redis?.url) {
      try {
        const store = new RedisMemoryStore(config.redis, config.embedding.dimensions);
        await store.initialize();
        return store;
      } catch (err) {
        console.warn(`[muma-mem] Redis connection failed (${(err as Error).message}), falling back to SQLite`);
      }
    }

    // Fallback to SQLite (degraded: no pub/sub)
    const sqlitePath = config.sqlite?.path ?? "memory-muma.db";
    const store = new SQLiteMemoryStore({ path: sqlitePath }, config.embedding.dimensions);
    await store.initialize();
    return store;
  }
  ```

  2. **src/plugin.ts** — Plugin registration logic:

  This module exports a `registerPlugin` function that takes the OpenClaw plugin API and wires up the lifecycle hooks. It does NOT import from `openclaw/plugin-sdk` directly — instead it uses the API object passed at registration time, keeping the plugin SDK as a peer/dev dependency only.

  ```typescript
  import type { MumaConfig } from "./config.js";
  import { MumaConfigSchema } from "./config.js";
  import { createStore } from "./store/factory.js";
  import { createEmbeddingProvider } from "./embedding/factory.js";
  import { validateEmbeddingDimensions } from "./embedding/validation.js";
  import type { MemoryStore } from "./types/store.js";
  import type { EmbeddingProvider } from "./embedding/types.js";

  // Module-level state (lives for gateway lifetime)
  let store: MemoryStore | null = null;
  let embeddingProvider: EmbeddingProvider | null = null;

  export function getStore(): MemoryStore {
    if (!store) throw new Error("[muma-mem] Store not initialized. Is the gateway running?");
    return store;
  }

  export function getEmbeddingProvider(): EmbeddingProvider {
    if (!embeddingProvider) throw new Error("[muma-mem] Embedding provider not initialized.");
    return embeddingProvider;
  }

  export function registerPlugin(api: any): void {
    // Parse and validate config
    const rawConfig = api.pluginConfig ?? {};
    const config: MumaConfig = MumaConfigSchema.parse(rawConfig);

    // gateway_start: initialize storage + embedding
    api.on("gateway_start", async () => {
      api.logger.info("[muma-mem] Initializing...");

      // 1. Create embedding provider
      embeddingProvider = await createEmbeddingProvider(config);
      api.logger.info(`[muma-mem] Embedding: ${embeddingProvider.modelName} (${embeddingProvider.dimensions}d)`);

      // 2. Create storage backend (Redis → SQLite fallback)
      store = await createStore(config);
      api.logger.info(`[muma-mem] Storage: ${store.backend}`);

      // 3. Validate embedding dimensions (STORE-05)
      const validation = await validateEmbeddingDimensions(embeddingProvider, store);
      if (!validation.ok) {
        api.logger.error(`[muma-mem] ${validation.error}`);
        throw new Error(validation.error);
      }

      api.logger.info("[muma-mem] Ready.");
    });

    // gateway_stop: cleanup
    api.on("gateway_stop", async () => {
      api.logger.info("[muma-mem] Shutting down...");
      if (store) {
        await store.close();
        store = null;
      }
      if (embeddingProvider) {
        await embeddingProvider.close();
        embeddingProvider = null;
      }
      api.logger.info("[muma-mem] Shutdown complete.");
    });
  }
  ```

  3. **src/index.ts** — Plugin default export matching OpenClaw's expected plugin shape:

  ```typescript
  import { MumaConfigSchema } from "./config.js";
  import { registerPlugin } from "./plugin.js";

  // Re-export types for consumers
  export type { Note, NoteCreate, NoteUpdate, Visibility, MemorySource } from "./types/note.js";
  export type { MemoryStore, VectorSearchOptions, VectorSearchResult } from "./types/store.js";
  export type { EmbeddingProvider } from "./embedding/types.js";
  export type { MumaConfig } from "./config.js";
  export { MumaConfigSchema } from "./config.js";
  export { getStore, getEmbeddingProvider } from "./plugin.js";

  const memoryMumaPlugin = {
    id: "memory-muma",
    name: "MUMA-Mem",
    description: "Multi-user multi-agent memory with ACT-R activation, Ebbinghaus forgetting, and semantic note linking",
    kind: "memory" as const,
    configSchema: MumaConfigSchema,
    register: registerPlugin,
  };

  export default memoryMumaPlugin;
  ```

  **Key design decisions:**
  - The plugin uses `api.on("gateway_start")` and `api.on("gateway_stop")` hooks for lifecycle (not registerService) because this matches OpenClaw's hook-based plugin model
  - Module-level state (store, embeddingProvider) lives for the gateway process lifetime
  - `getStore()` and `getEmbeddingProvider()` are exported for use by other modules (tools, hooks in Phase 2+)
  - Config is validated at registration time with Zod, before any hook fires
  - The `api` parameter is typed as `any` to avoid hard dependency on openclaw/plugin-sdk types at runtime — we only use the documented API surface (on, logger, pluginConfig)
  </action>
  <verify>
  - `pnpm run typecheck` passes
  - `pnpm run build` succeeds, dist/ contains all files
  - Plugin default export has id, name, kind, configSchema, register
  </verify>
  <done>Plugin entry point registers gateway lifecycle hooks. Storage factory auto-detects Redis→SQLite. Dimension validation runs on startup. All types re-exported for consumers.</done>
</task>

<task type="auto">
  <name>Task 2: End-to-end verification</name>
  <files>test/integration.ts</files>
  <action>
  Create an integration test that exercises the full stack WITHOUT OpenClaw (standalone usage):

  **test/integration.ts**:
  ```typescript
  // Test: create store + embedding provider, store note, search, verify round-trip
  ```

  The test should:
  1. Parse config with MumaConfigSchema (empty → defaults)
  2. Create SQLite store (in-memory, no Redis needed for test)
  3. Create local embedding provider
  4. Initialize both
  5. Validate dimensions (should pass — both use 384)
  6. Embed "User prefers TypeScript over JavaScript"
  7. Create a note with that embedding, user_id="test-user", created_by="test-agent"
  8. Verify all 22 Note fields are populated
  9. Read the note back by ID, verify content matches
  10. Embed "What programming language does the user prefer?"
  11. Search with that embedding, expect the note is returned with score > 0
  12. Update the note content, verify version incremented
  13. Delete the note, verify countByUser returns 0
  14. Close store and provider
  15. Print "All tests passed"

  Run with: `npx tsx test/integration.ts`

  This test validates:
  - STORE-01: Data persists (read after create works)
  - STORE-02: SQLite backend works
  - STORE-03: User isolation (search scoped to user_id)
  - STORE-04: Local embedding works
  - STORE-05: Dimension validation passes
  - PLUG-08: All metadata fields populated

  If any assertion fails, throw an Error with a descriptive message.
  Use simple assert-style checks (no test framework needed):
  ```typescript
  function assert(condition: boolean, message: string): asserts condition {
    if (!condition) throw new Error(`FAIL: ${message}`);
  }
  ```
  </action>
  <verify>
  - `npx tsx test/integration.ts` prints "All tests passed" with no errors
  - Test covers: create, read, update, delete, search, embed, dimension validation
  </verify>
  <done>End-to-end integration test passes. All Phase 1 requirements verified: persistence, dual backends, user isolation, local embeddings, dimension validation, metadata fields.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes with zero errors
- [ ] `pnpm run build` produces clean dist/ output
- [ ] Plugin default export matches OpenClaw's expected shape (id, kind, configSchema, register)
- [ ] Storage factory tries Redis then falls back to SQLite
- [ ] Integration test passes end-to-end
- [ ] All Phase 1 requirements covered (STORE-01 through STORE-07, PLUG-01, PLUG-05, PLUG-08)
</verification>

<success_criteria>

- All tasks completed
- Plugin registers gateway_start and gateway_stop hooks
- Storage auto-detects Redis → SQLite fallback
- Dimension mismatch detection blocks startup on mismatch
- Integration test validates all 10 Phase 1 requirements
- Package exports clean public API (types + getStore + getEmbeddingProvider)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
