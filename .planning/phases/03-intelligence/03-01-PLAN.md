---
phase: 03-intelligence
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [src/activation/scoring.ts, src/activation/decay.ts, src/activation/index.ts, src/activation/__tests__/scoring.test.ts, src/activation/__tests__/decay.test.ts, vitest.config.ts, package.json]
autonomous: true
---

<objective>
Implement ACT-R activation scoring and Ebbinghaus decay as pure, tested math functions.

Purpose: These functions are the core intelligence differentiator — they determine which memories surface and which fade. TDD ensures correctness of the mathematical models before integration.
Output: Tested activation scoring and decay modules with Vitest infrastructure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/note.ts
@src/config.ts
@package.json
</context>

<feature>
  <name>ACT-R activation scoring + Ebbinghaus decay</name>
  <files>
    src/activation/scoring.ts
    src/activation/decay.ts
    src/activation/index.ts
    src/activation/__tests__/scoring.test.ts
    src/activation/__tests__/decay.test.ts
    vitest.config.ts
    package.json
  </files>
  <behavior>
    ## Scoring Functions (src/activation/scoring.ts)

    **baseLevelActivation(accessLog: string[], now: Date, d: number): number**
    ACT-R base-level learning equation: B_i = ln(Σ_j t_j^(-d))
    where t_j = hours elapsed since j-th access.

    For large access counts (>50), use Petrov 2006 hybrid approximation:
    B_i ≈ ln(n / (1-d)) - d * ln(L)
    where n = access count, L = hours since first access.

    Cases:
    - ([], now, 0.5) → -Infinity (no history)
    - ([now - 1h], now, 0.5) → ln(1^(-0.5)) = ln(1.0) = 0.0
    - ([now - 0.01h], now, 0.5) → ln(100^0.5) = ln(10) ≈ 2.302
    - ([now - 1h, now - 2h], now, 0.5) → ln(1 + 2^(-0.5)) = ln(1.707) ≈ 0.535
    - 100 accesses spread over 100h → uses Petrov approximation ≈ ln(100/0.5) - 0.5*ln(100) ≈ 5.298 - 2.302 ≈ 2.996

    **spreadingActivation(similarity: number, contextWeight: number): number**
    S_i = W * similarity (simple linear spreading from query context)
    - (1.0, 11.0) → 11.0
    - (0.5, 11.0) → 5.5
    - (0.0, 11.0) → 0.0

    **stochasticNoise(sigma: number): number**
    ACT-R uses logistic distribution with scale s = sigma * sqrt(3) / π.
    Generate via inverse CDF: s * ln(u / (1 - u)) where u ~ Uniform(0,1).
    - Statistical test: N=10000 samples with σ=1.2, mean within ±0.15 of 0, stddev within ±0.2 of σ

    **totalActivation(base: number, spreading: number, noise: number): number**
    A_i = B_i + S_i + ε_i
    - (2.0, 5.5, 0.1) → 7.6
    - (-Infinity, 5.5, 0.1) → -Infinity (no base)

    ## Decay Functions (src/activation/decay.ts)

    **computeRetention(halfLife: number, elapsedHours: number): number**
    Ebbinghaus: R(t) = 2^(-t / halfLife)
    - (168, 0) → 1.0
    - (168, 168) → 0.5
    - (168, 336) → 0.25

    **reinforceHalfLife(halfLife: number, factor?: number): number**
    On successful retrieval, half-life increases proportionally.
    new_hl = halfLife * (1 + factor), default factor = 0.1
    - (168, 0.1) → 184.8
    - (168, 0.2) → 201.6
    - (100) → 110 (default factor)

    **isPruningCandidate(activation: number, threshold: number, pinned: boolean): boolean**
    Memory is a pruning candidate if activation is below threshold AND not pinned.
    - (-3.0, -2.0, false) → true
    - (1.0, -2.0, false) → false
    - (-3.0, -2.0, true) → false (pinned exempt)
  </behavior>
  <implementation>
    **Vitest setup (RED phase prerequisite):**
    - `pnpm add -D vitest`
    - Create vitest.config.ts with `globals: true` and `include: ['src/**/*.test.ts']`
    - Add `"test": "vitest run"` script to package.json

    **src/activation/scoring.ts:**
    - Export baseLevelActivation, spreadingActivation, stochasticNoise, totalActivation
    - baseLevelActivation: Parse ISO timestamps → compute hour deltas → sum t^(-d) → ln(sum)
      For accessLog.length > 50: use Petrov approximation
    - stochasticNoise: Use Math.random() for uniform, apply logistic inverse CDF
    - All functions are pure (no side effects, no imports from plugin.ts)

    **src/activation/decay.ts:**
    - Export computeRetention, reinforceHalfLife, isPruningCandidate
    - All pure math functions
    - reinforceHalfLife: default factor from DecayConfig or hardcoded 0.1

    **src/activation/index.ts:**
    - Barrel export from scoring.ts and decay.ts
  </implementation>
</feature>

<verification>
- `pnpm test` passes all activation and decay tests
- `pnpm run typecheck` passes
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- All implementations pass tests (GREEN)
- Refactor complete if needed
- 2-3 commits present following TDD pattern
- ACT-01, ACT-02, ACT-03, FORGET-01, FORGET-03, FORGET-04 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/03-intelligence/03-01-SUMMARY.md`
</output>
