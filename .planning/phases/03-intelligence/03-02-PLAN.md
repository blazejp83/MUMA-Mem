---
phase: 03-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [src/types/note.ts, src/store/redis.ts, src/store/sqlite.ts, src/activation/tracking.ts, src/activation/index.ts, src/pipeline/read.ts, src/plugin.ts, src/index.ts]
autonomous: true
---

<objective>
Integrate ACT-R activation scoring into the search pipeline, replacing flat cosine similarity ranking with combined activation-based ranking, and wire proper access tracking with half-life reinforcement.

Purpose: This makes search "intelligent" — frequently accessed, recently used, and contextually relevant memories rank higher than stale ones, even if vector similarity is equal.
Output: Search results ranked by ACT-R activation score. Access tracking records timestamps and reinforces half-life on retrieval.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-intelligence/03-01-SUMMARY.md

@src/types/note.ts
@src/types/store.ts
@src/pipeline/read.ts
@src/store/redis.ts
@src/store/sqlite.ts
@src/plugin.ts
@src/config.ts
@src/activation/scoring.ts
@src/activation/decay.ts
@src/activation/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend NoteUpdate and store implementations for activation metadata</name>
  <files>src/types/note.ts, src/store/redis.ts, src/store/sqlite.ts, src/plugin.ts</files>
  <action>
    1. **Extend NoteUpdate** in src/types/note.ts — add optional fields:
       - access_count?: number
       - access_log?: string[]
       - activation?: number
       - half_life?: number

    2. **Update RedisMemoryStore.update()** in src/store/redis.ts:
       - Remove hardcoded preservation of access_count, access_log, activation, half_life
       - Instead, use updates.access_count ?? existing.access_count (same pattern as other fields)
       - This allows the tracking module to update these fields via store.update()

    3. **Update SQLiteMemoryStore.update()** in src/store/sqlite.ts:
       - Same pattern: allow activation metadata fields to be updated
       - Add access_count, access_log, activation, half_life to the UPDATE SQL statement
       - Use merged values (updates ?? existing) like other fields

    4. **Add getConfig() accessor** to src/plugin.ts:
       - Store parsed MumaConfig as module-level singleton (alongside store, embeddingProvider, llmProvider)
       - Export getConfig() function that returns it
       - Set it during registerPlugin before gateway_start

    5. **Re-export getConfig** from src/index.ts
  </action>
  <verify>
    - `pnpm run typecheck` passes
    - Existing tests still pass: `pnpm test`
  </verify>
  <done>
    - NoteUpdate accepts activation metadata fields
    - Both store implementations handle activation field updates
    - getConfig() accessible from any module
  </done>
</task>

<task type="auto">
  <name>Task 2: Create access tracking module and integrate activation-based search ranking</name>
  <files>src/activation/tracking.ts, src/activation/index.ts, src/pipeline/read.ts</files>
  <action>
    1. **Create src/activation/tracking.ts** with:

       `trackAccess(noteId: string, userId: string, currentNote: Note, store: MemoryStore, config: MumaConfig): Promise<void>`
       - Appends current ISO timestamp to note's access_log
       - Increments access_count
       - Calls reinforceHalfLife() from decay.ts to compute new half_life
       - Calls baseLevelActivation() to recompute activation score
       - Writes all updates via store.update() (using the newly extended NoteUpdate)
       - Non-blocking (caller uses void/catch pattern)

    2. **Update src/activation/index.ts** barrel to export tracking.ts

    3. **Modify src/pipeline/read.ts** search function:

       Current flow: embed → vector search → build results → expand links → fire-and-forget empty update
       New flow:
       a. Embed query (unchanged)
       b. Vector search with **2x overfetch** (topK * 2) to get larger candidate pool for re-ranking
       c. For each candidate, compute total ACT-R activation:
          - base = baseLevelActivation(note.access_log, now, config.activation.decayParameter)
          - spreading = spreadingActivation(vectorSimilarity, config.activation.contextWeight)
          - noise = stochasticNoise(config.activation.noiseStddev)
          - total = totalActivation(base, spreading, noise)
       d. Filter: remove results where total activation < config.activation.retrievalThreshold
       e. Sort by total activation descending
       f. Take top-K from sorted results
       g. Expand links (unchanged)
       h. Fire-and-forget trackAccess() for each result (replaces empty store.update)

       **Update SearchResult interface:**
       - Keep existing `score` field (rename to `similarity` for clarity)
       - Add `activationScore: number` — the combined ACT-R activation
       - The results are now sorted by activationScore, not similarity

       **Import getConfig()** from plugin.ts for activation parameters.

       **Important:** Don't break the search function signature. SearchOptions stays the same. SearchResult gets the additional field. Callers that only use `score` still work (keep score as the activation score for backward compat, add `similarity` as the raw vector score).

       Actually — to minimize breaking changes: keep `score` as the PRIMARY ranking score (now activation-based). Add `similarity: number` as a new field for the raw vector similarity. This way existing consumers that sort by score get activation ranking automatically.
  </action>
  <verify>
    - `pnpm run typecheck` passes
    - `pnpm test` passes (activation math tests from Plan 01)
    - Manual review: search() now imports from activation module and computes ACT-R scores
  </verify>
  <done>
    - Search results ranked by combined ACT-R activation score (ACT-05, SEARCH-03)
    - Access tracking records timestamps and reinforces half-life (ACT-04, FORGET-02)
    - SearchResult exposes both activationScore and raw similarity
    - Retrieval threshold filters low-activation results
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes
- [ ] `pnpm test` passes
- [ ] search() computes activation scores for results
- [ ] trackAccess() records timestamps and reinforces half_life
- [ ] NoteUpdate accepts activation metadata fields
- [ ] Both Redis and SQLite stores handle activation field updates
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- ACT-04, ACT-05, SEARCH-03, FORGET-02 requirements addressed
- Search ranking uses activation instead of raw similarity
</success_criteria>

<output>
After completion, create `.planning/phases/03-intelligence/03-02-SUMMARY.md`
</output>
