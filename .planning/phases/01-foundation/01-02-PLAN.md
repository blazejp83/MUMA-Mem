---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/embedding/local.ts
  - src/embedding/remote.ts
  - src/embedding/factory.ts
  - src/embedding/validation.ts
  - package.json
autonomous: true
---

<objective>
Implement the embedding provider abstraction with local (all-MiniLM-L6-v2) and remote (OpenAI-compatible) adapters, plus startup dimension mismatch detection.

Purpose: STORE-04 requires local embedding by default with configurable remote override. STORE-05 requires dimension mismatch detection on startup. Both storage backends need embeddings for vector search.

Output: Working EmbeddingProvider implementations that generate 384-dim (local) or configurable-dim (remote) vectors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@src/embedding/types.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement local and remote embedding providers</name>
  <files>src/embedding/local.ts, src/embedding/remote.ts, src/embedding/factory.ts, package.json</files>
  <action>
  1. Install: `pnpm add @huggingface/transformers` for local embeddings

  2. **src/embedding/local.ts** — LocalEmbeddingProvider:
  - Implements EmbeddingProvider interface from src/embedding/types.ts
  - Uses `@huggingface/transformers` pipeline API:
    ```typescript
    import { pipeline, type FeatureExtractionPipeline } from "@huggingface/transformers";
    ```
  - `initialize()`: Create pipeline with `pipeline("feature-extraction", modelName)` where modelName defaults to "Xenova/all-MiniLM-L6-v2". Store pipeline instance.
  - `embed(text)`: Call pipeline with `{ pooling: "mean", normalize: true }`, convert output to Float32Array. Output is 384-dimensional.
  - `embedBatch(texts)`: Call pipeline with array input, same options. Return array of Float32Array.
  - `dimensions`: 384 (for MiniLM-L6-v2). Read from config or detect from first embedding.
  - `close()`: No-op (pipeline cleanup handled by GC).
  - Handle first-run model download gracefully — the model (~23MB) is downloaded and cached automatically by transformers.js.

  3. **src/embedding/remote.ts** — RemoteEmbeddingProvider:
  - Implements EmbeddingProvider interface
  - Uses native `fetch()` (Node 22+ has global fetch) to call OpenAI-compatible embedding API
  - `initialize()`: Validate apiKey and baseUrl exist. Set baseUrl default to "https://api.openai.com/v1".
  - `embed(text)`: POST to `{baseUrl}/embeddings` with model and input. Parse response, extract embedding array, convert to Float32Array.
  - `embedBatch(texts)`: Same endpoint accepts array input. Parse all embeddings from response.
  - `dimensions`: Read from config, or detect from first embedding response.
  - `close()`: No-op.
  - Error handling: throw descriptive errors on 401 (bad key), 429 (rate limit), network failures.

  4. **src/embedding/factory.ts** — Provider factory:
  ```typescript
  import type { EmbeddingProvider } from "./types.js";
  import type { MumaConfig } from "../config.js";
  import { LocalEmbeddingProvider } from "./local.js";
  import { RemoteEmbeddingProvider } from "./remote.js";

  export async function createEmbeddingProvider(config: MumaConfig): Promise<EmbeddingProvider> {
    const provider = config.embedding.provider === "openai"
      ? new RemoteEmbeddingProvider(config.embedding)
      : new LocalEmbeddingProvider(config.embedding);
    await provider.initialize();
    return provider;
  }
  ```

  All imports use `.js` extensions for ESM. No CommonJS patterns.
  </action>
  <verify>
  - `pnpm run typecheck` passes
  - Write a quick test script (test/embedding-smoke.ts) that:
    1. Creates LocalEmbeddingProvider with default config
    2. Calls initialize()
    3. Embeds "Hello world"
    4. Asserts output is Float32Array with length 384
    5. Run with: `npx tsx test/embedding-smoke.ts`
  </verify>
  <done>Local provider generates 384-dim embeddings from all-MiniLM-L6-v2. Remote provider calls OpenAI-compatible API. Factory creates correct provider from config.</done>
</task>

<task type="auto">
  <name>Task 2: Implement embedding dimension mismatch detection</name>
  <files>src/embedding/validation.ts</files>
  <action>
  **src/embedding/validation.ts** — Startup validation for STORE-05:

  ```typescript
  import type { EmbeddingProvider } from "./types.js";
  import type { MemoryStore } from "../types/store.js";

  export interface DimensionValidationResult {
    ok: boolean;
    providerDimensions: number;
    storedDimensions: number | null;
    error?: string;
  }

  export async function validateEmbeddingDimensions(
    provider: EmbeddingProvider,
    store: MemoryStore,
  ): Promise<DimensionValidationResult> {
    // ...
  }
  ```

  Logic:
  1. Get provider dimensions from `provider.dimensions`
  2. Get stored dimensions from `store.dimensions` (null if no vectors stored yet)
  3. If stored is null → OK (first run, no mismatch possible)
  4. If stored !== provider → FAIL with descriptive error:
     "Embedding dimension mismatch: store contains {stored}-dim vectors but provider generates {provider}-dim vectors. This will cause silent retrieval failures. Either switch back to the previous embedding provider or re-embed all existing memories."
  5. If stored === provider → OK

  This function should be called during gateway_start (Plan 05). It prevents the scenario where a user switches from local (384-dim) to OpenAI (1536-dim) without re-indexing.
  </action>
  <verify>`pnpm run typecheck` passes — validation function compiles correctly</verify>
  <done>Dimension validation detects mismatches between embedding provider and stored vectors. Returns descriptive error message for STORE-05.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes
- [ ] LocalEmbeddingProvider generates 384-dim Float32Array embeddings
- [ ] RemoteEmbeddingProvider compiles (runtime test requires API key)
- [ ] Factory creates correct provider based on config
- [ ] Dimension validation function detects mismatches
</verification>

<success_criteria>

- All tasks completed
- Local embeddings work end-to-end (model download + inference)
- Type safety maintained across provider interface
- Dimension mismatch detection prevents silent retrieval failures (STORE-05)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
