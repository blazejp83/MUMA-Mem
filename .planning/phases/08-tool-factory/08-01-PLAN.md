---
phase: 08-tool-factory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/tools/index.ts, src/plugin.ts]
autonomous: true
---

<objective>
Convert all 10 agent tools from direct-object registration to the OpenClaw factory pattern with correct execute(toolCallId, params) signature, underscore naming, and labels.

Purpose: Align MUMA-Mem's tool registration with the actual OpenClaw plugin SDK — tools must use the factory pattern where context (userId, agentId) comes from the factory closure, not from execute-time arguments.
Output: Rewritten src/tools/index.ts using factory pattern; updated src/plugin.ts moving tool registration to register() time.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/INTEGRATION-SPEC.md

# Phase 6 established the OpenClaw types we need:
@.planning/phases/06-integration-types/06-01-SUMMARY.md

# Source files to modify:
@src/tools/index.ts
@src/plugin.ts
@src/types/openclaw.ts
@src/utils/deriveUserId.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite tools/index.ts to factory pattern</name>
  <files>src/tools/index.ts</files>
  <action>
  Rewrite `registerTools(api)` to register a single `OpenClawPluginToolFactory` via `api.registerTool(factory, opts)`.

  **Factory pattern:**
  - The function signature becomes: `export function registerTools(api: OpenClawPluginApi): void`
  - Inside, call `api.registerTool(factory, { names: [...all 10 tool names...] })` once
  - The factory function receives `ctx: OpenClawPluginToolContext` and returns `AgentTool[]`
  - Factory derives `userId` from `ctx.sessionKey` via `deriveUserId(ctx.sessionKey)` and captures `agentId` from `ctx.agentId ?? "unknown"`
  - These are captured in the closure — NOT passed as execute args

  **For each of the 10 tools, apply these changes:**

  1. **Rename** from dot notation to underscores:
     - `memory.write` → `memory_write`
     - `memory.query` → `memory_query`
     - `memory.forget` → `memory_forget`
     - `memory.pin` → `memory_pin`
     - `memory.set_visibility` → `memory_set_visibility`
     - `memory.get_context` → `memory_get_context`
     - `memory.stats` → `memory_stats`
     - `memory.link` → `memory_link`
     - `memory.search_agents` → `memory_search_agents`
     - `memory.consolidate` → `memory_consolidate`

  2. **Add `label` field** to each tool (e.g., "Memory Write", "Memory Query", etc.)

  3. **Fix `execute` signature** from `(params, context)` to `(toolCallId: string, params: unknown)`:
     - First arg is `toolCallId` (string) — unused by our tools but required by SDK
     - Second arg is `params` (unknown) — cast to expected shape inside execute body
     - Remove old `context: any` parameter entirely

  4. **Access userId/agentId from factory closure** instead of `context.userId`/`context.agentId`:
     - The factory closure captures `userId` and `agentId` at tool-creation time
     - All tool execute bodies reference these closure variables

  5. **Keep JSON Schema parameters** — do NOT switch to TypeBox. The integration spec decision was to keep JSON Schema objects since TypeBox produces JSON Schema-compatible output.

  **Import changes:**
  - Add imports for `OpenClawPluginApi`, `OpenClawPluginToolContext`, `AgentTool` from `../types/openclaw.js`
  - Add import for `deriveUserId` from `../utils/index.js`

  **Special attention for tools that use `context.sessionId`:**
  - `memory_get_context` currently uses `context.sessionId` for L1 working memory lookup. The factory `ctx` does not have `sessionId` directly, but has `sessionKey`. Since the sessions Map in plugin.ts is keyed by `sessionId` (from hook context), and the tool factory ctx only has `sessionKey`, L1 lookup via getWorkingMemory won't work here. Keep the L1 section but use a comment noting this limitation — `sessionKey` can't be used to look up sessionId-keyed working memory. The L2 section still works fine.
  </action>
  <verify>npx tsc --noEmit passes with no type errors in src/tools/index.ts</verify>
  <done>All 10 tools use factory pattern with correct (toolCallId, params) execute signature, underscore names, and label fields. Factory derives userId/agentId from OpenClawPluginToolContext closure.</done>
</task>

<task type="auto">
  <name>Task 2: Move tool registration from gateway_start to registerPlugin</name>
  <files>src/plugin.ts</files>
  <action>
  In `src/plugin.ts`, move the `registerTools(api)` call from inside the `gateway_start` handler to the `registerPlugin()` function body (after config parsing, before any `api.on()` calls).

  **Why:** With the factory pattern, `api.registerTool(factory)` just registers the factory — it doesn't execute it. OpenClaw calls the factory per-session when tools are needed. By that time, `gateway_start` will have initialized all singletons (store, embedding, etc.). So registration at register() time is correct.

  **Specific changes:**
  1. Move `registerTools(api);` from inside `api.on("gateway_start", ...)` to after `mumaConfig = config;` in `registerPlugin()`
  2. Move the `api.logger.info("[muma-mem] Agent tools registered.");` log line alongside it
  3. No other changes to plugin.ts
  </action>
  <verify>npx tsc --noEmit passes; grep -n "registerTools" src/plugin.ts shows it's called in registerPlugin body, not inside gateway_start</verify>
  <done>registerTools(api) called at registration time, not gateway_start time. Factory pattern correctly defers tool instantiation to per-session calls by OpenClaw.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds with no errors
- [ ] All 10 tools present in factory return array
- [ ] All tools have: label, name (underscore), description, parameters (JSON Schema), execute(toolCallId, params)
- [ ] Factory captures userId via deriveUserId(ctx.sessionKey) and agentId via ctx.agentId
- [ ] registerTools called in registerPlugin() body, not inside gateway_start
- [ ] No references to old dot-notation tool names remain
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- Tool registration uses OpenClaw factory pattern
- Execute signature matches SDK: (toolCallId: string, params: unknown) => unknown
- Tool names use underscores not dots
- All tools have label field
  </success_criteria>

<output>
After completion, create `.planning/phases/08-tool-factory/08-01-SUMMARY.md`
</output>
