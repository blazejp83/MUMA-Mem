---
phase: 04-multi-agent
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified: [src/pipeline/read.ts, src/pipeline/construct.ts, src/access/transactive.ts, src/access/index.ts, src/tools/index.ts, src/index.ts, src/plugin.ts]
autonomous: true
---

<objective>
Integrate visibility gate into read/write pipelines, add transactive memory index, and register 5 new agent tools.

Purpose: Enforces the two-axis access model in the search pipeline (VIS-04), applies domain visibility rules on writes (VIS-03), tracks agent expertise (AGENT-04), and provides the remaining PLUG-07 tools.
Output: Visibility-gated search, domain-rule-aware writes, transactive memory routing, and complete agent tool set.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Depends on Plan 01 output (access control module):
@src/access/visibility.ts
@src/access/index.ts

# Depends on Plan 02 output (event bus):
@src/sync/events.ts

# Files being modified:
@src/pipeline/read.ts
@src/pipeline/construct.ts
@src/tools/index.ts
@src/plugin.ts
@src/config.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Visibility gate in read pipeline + domain rules in write pipeline</name>
  <files>src/pipeline/read.ts, src/pipeline/construct.ts, src/plugin.ts</files>
  <action>
    **Read pipeline (src/pipeline/read.ts):**

    1. Add `agentId?: string` to SearchOptions interface. Optional — when omitted, no visibility filtering (backward compat for direct API consumers).

    2. After vector search (step 2) and BEFORE activation scoring (step 3), add visibility gate:
       ```
       // Visibility gate (VIS-04): filter unauthorized notes before scoring
       let candidates = vectorResults;
       if (agentId) {
         const profile = resolveAgentProfile(agentId, config);
         candidates = vectorResults.filter(vr => canAgentSeeNote(vr.note, agentId, profile));
       }
       ```
       Then use `candidates` instead of `vectorResults` in the activation scoring loop.

    3. Import resolveAgentProfile and canAgentSeeNote from "../access/index.js".

    **Write pipeline (src/pipeline/construct.ts):**

    4. After building the NoteCreate object, apply domain visibility rules:
       ```
       // VIS-03: Domain rules override LLM-suggested visibility
       import { applyDomainRule } from "../access/index.js";
       import { getConfig } from "../plugin.js";

       const config = getConfig();
       const ruleVisibility = applyDomainRule(
         facts.domain,
         config.visibility.domainRules,
         config.visibility.defaultVisibility
       );
       // Domain rule takes precedence over LLM extraction
       noteCreate.visibility = ruleVisibility;
       ```
       Place this AFTER the return object is built. The domain rule is the authority — it overrides whatever the LLM suggested. If no rule matches, the config's defaultVisibility applies.

    **Plugin before_agent_start (src/plugin.ts):**

    5. In the before_agent_start hook, pass agentId to the L2 search call:
       ```
       const l2Results = await search({
         query: queryText,
         userId,
         agentId,  // NEW: enables visibility filtering
         topK: 10,
       });
       ```
       This is a one-line change — just add agentId to the search options.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
    - Search pipeline filters notes by visibility before activation scoring
    - Unauthorized notes never appear in results (VIS-04)
    - Write pipeline applies domain visibility rules from config (VIS-03)
    - before_agent_start passes agentId for visibility-filtered L2 search
  </done>
</task>

<task type="auto">
  <name>Task 2: Transactive memory index + 5 new agent tools</name>
  <files>src/access/transactive.ts, src/access/index.ts, src/tools/index.ts, src/index.ts, src/plugin.ts</files>
  <action>
    **Transactive Memory Index (src/access/transactive.ts):**

    1. Create a TransactiveMemoryIndex class:
       ```
       class TransactiveMemoryIndex {
         // agentId → Map<domain, writeCount>
         private index: Map<string, Map<string, number>> = new Map();

         recordWrite(agentId: string, domain: string): void
           // Increment write count for agent+domain pair

         getExpertsForDomain(domain: string, topK?: number): Array<{agentId: string, writeCount: number}>
           // Find agents with most writes to this domain (or prefix-matching domains)
           // Sort by writeCount descending, return topK (default 5)

         getDomainsForAgent(agentId: string): Array<{domain: string, writeCount: number}>
           // List domains an agent has written to, sorted by writeCount descending

         clear(): void
       }
       ```
       Export class and create factory: `createTransactiveIndex(): TransactiveMemoryIndex`

    2. Update src/access/index.ts to re-export TransactiveMemoryIndex.

    **Wire transactive index into plugin (src/plugin.ts):**

    3. Add module-level: `let transactiveIndex: TransactiveMemoryIndex | null = null;`
    4. Add accessor: `export function getTransactiveIndex(): TransactiveMemoryIndex | null { return transactiveIndex; }`
    5. In gateway_start: `transactiveIndex = createTransactiveIndex();`
    6. In gateway_stop: `transactiveIndex?.clear(); transactiveIndex = null;`
    7. Subscribe to event bus to update transactive index:
       ```
       if (eventBus) {
         eventBus.subscribe((event) => {
           if (event.type === "memory:write" || event.type === "memory:update") {
             transactiveIndex?.recordWrite(event.agentId, event.domain);
           }
         });
       }
       ```

    **5 New Agent Tools (src/tools/index.ts):**

    8. Add these tools AFTER the existing 5 tools in registerTools():

    a. **memory.get_context** — Get current memory context for this agent
       - Parameters: { topK?: number (default 10) }
       - Execute: Call search({ query: "", userId, agentId, topK }) to get visibility-filtered recent memories
       - Actually, empty query won't embed well. Instead: use getWorkingMemory(sessionId) for L1, and store.listByUser(userId, {limit: topK}) for L2, filtered by canAgentSeeNote.
       - Return: { l1: WorkingMemoryItem[], l2: Note[] }

    b. **memory.stats** — Memory statistics
       - Parameters: none
       - Execute: Call store.countByUser(userId), compute activation distribution by scanning listByUser
       - Return: { totalMemories: number, backend: string, activationDistribution: { high: number, medium: number, low: number } }
       - High: activation > 2.0, Medium: 0 to 2.0, Low: < 0

    c. **memory.link** — Manually link two notes
       - Parameters: { noteId: string, targetNoteId: string }
       - Execute: Read both notes, add each to other's links array via store.update, ensure bidirectional
       - Return: { success: boolean, noteId: string, targetNoteId: string }

    d. **memory.search_agents** — Find agents with expertise in a domain
       - Parameters: { domain: string, topK?: number (default 5) }
       - Execute: Use transactiveIndex.getExpertsForDomain(domain, topK)
       - Return: Array<{ agentId: string, writeCount: number }>

    e. **memory.consolidate** — Trigger manual consolidation (Phase 5 placeholder)
       - Parameters: none
       - Execute: Return status message that consolidation is not yet available
       - Return: { status: "not_available", message: "Consolidation will be available in a future version." }

    **Exports (src/index.ts):**

    9. Add exports: getTransactiveIndex, TransactiveMemoryIndex type
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
    - TransactiveMemoryIndex tracks agent→domain writes and routes queries
    - Event bus updates transactive index on write/update events
    - 5 new tools registered: memory.get_context, memory.stats, memory.link, memory.search_agents, memory.consolidate
    - Total: 10 agent tools (5 existing + 5 new, satisfying PLUG-06 + PLUG-07)
    - All types exported from src/index.ts
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] Search with agentId filters notes by visibility (VIS-04)
- [ ] Search without agentId returns all notes for userId (backward compat)
- [ ] Write pipeline applies domain rules from config (VIS-03)
- [ ] before_agent_start passes agentId to search
- [ ] TransactiveMemoryIndex correctly tracks and queries agent expertise
- [ ] All 10 agent tools registered (5 old + 5 new)
- [ ] All new types exported from src/index.ts
</verification>

<success_criteria>
- All tasks completed
- TypeScript compiles without errors
- Visibility gate enforced in read pipeline
- Domain rules applied in write pipeline
- Transactive memory index wired to event bus
- 10 agent tools total
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-agent/04-03-SUMMARY.md`
</output>
