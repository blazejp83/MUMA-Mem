---
phase: 12-cross-channel-identity-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.ts
  - src/utils/deriveUserId.ts
  - src/utils/__tests__/deriveUserId.test.ts
  - src/utils/index.ts
  - src/plugin.ts
  - src/tools/index.ts
autonomous: true
---

<objective>
Add cross-channel identity mapping so the same human using multiple channels (e.g. Telegram + Discord) shares one memory store instead of having isolated stores per channel.

Purpose: Currently `deriveUserId` parses `"telegram:12345"` from sessionKey, meaning the same person on Discord gets a different userId and separate memories. An `identityMap` config lets users declare that multiple channel identities belong to the same person, unifying their memories under a canonical name.

Output: Updated config schema with `identityMap`, updated derive functions with reverse-map lookup, wired through all plugin hooks and tool factory, full unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/todos/pending/2026-02-17-cross-channel-identity-mapping.md

@src/config.ts
@src/utils/deriveUserId.ts
@src/utils/__tests__/deriveUserId.test.ts
@src/utils/index.ts
@src/plugin.ts
@src/tools/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add identityMap config + reverse map builder + update derive functions + tests</name>
  <files>src/config.ts, src/utils/deriveUserId.ts, src/utils/index.ts, src/utils/__tests__/deriveUserId.test.ts</files>
  <action>
    1. **Config** (`src/config.ts`): Add optional `identityMap` field to `MumaConfigSchema`:
       ```
       identityMap: z.record(z.string(), z.array(z.string())).optional()
       ```
       Format: `{ "alice": ["telegram:12345", "discord:98765"], "bob": ["slack:U456"] }`
       Key = canonical userId, value = list of channel identities that resolve to it.

    2. **Reverse map builder** (`src/utils/deriveUserId.ts`): Add exported `buildReverseIdentityMap` function:
       - Input: `identityMap?: Record<string, string[]>`
       - Output: `Map<string, string>` mapping each channel identity to its canonical name
       - Validates no duplicate channel identities across groups — throw Error with clear message if duplicate found
       - Returns empty Map if identityMap is undefined/empty

    3. **Update derive functions** (`src/utils/deriveUserId.ts`): Add optional `reverseIdentityMap?: Map<string, string>` parameter to both `deriveUserId` and `deriveUserIdFromMessageCtx`. After deriving the raw userId via existing logic, check `reverseIdentityMap.get(rawUserId)`. If found, return the canonical name. If not found (or no map provided), return the raw userId unchanged. This preserves full backward compatibility.

    4. **Update exports** (`src/utils/index.ts`): Add `buildReverseIdentityMap` to the re-export.

    5. **Tests** (`src/utils/__tests__/deriveUserId.test.ts`): Add describe blocks:
       - `buildReverseIdentityMap`: builds correct reverse map, throws on duplicate identity, returns empty map for undefined
       - `deriveUserId with identity map`: resolves to canonical name, falls back when not in map, backward compatible without map
       - `deriveUserIdFromMessageCtx with identity map`: resolves via reverse map, backward compatible without map
  </action>
  <verify>npx vitest run src/utils/__tests__/deriveUserId.test.ts</verify>
  <done>Both derive functions accept optional reverse identity map, resolve to canonical names when matched, fall back to raw userId otherwise. buildReverseIdentityMap validates uniqueness and returns Map. All unit tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire identity map through plugin hooks and tool factory</name>
  <files>src/plugin.ts, src/tools/index.ts</files>
  <action>
    1. **Plugin** (`src/plugin.ts`):
       - Import `buildReverseIdentityMap` from `./utils/index.js`
       - Add module-level state alongside existing singletons:
         `let reverseIdentityMap: Map<string, string> = new Map();`
       - In `registerPlugin()`, after parsing config (line 113), build the reverse map:
         `reverseIdentityMap = buildReverseIdentityMap(config.identityMap);`
       - Add public accessor (alongside existing getStore, getConfig, etc.):
         `export function getReverseIdentityMap(): Map<string, string> { return reverseIdentityMap; }`
       - Update ALL `deriveUserId` callsites to pass `reverseIdentityMap`:
         - before_agent_start (line 224): `deriveUserId(ctx.sessionKey, reverseIdentityMap)`
         - session_end (line 277): `deriveUserId(undefined, reverseIdentityMap)`
         - after_tool_call (line 449): `deriveUserId(ctx.sessionKey, reverseIdentityMap)`
       - Update `deriveUserIdFromMessageCtx` callsite:
         - message_received (line 413): `deriveUserIdFromMessageCtx(ctx, reverseIdentityMap)`
       - In `gateway_stop` handler, reset alongside other cleanup:
         `reverseIdentityMap = new Map();`

    2. **Tools** (`src/tools/index.ts`):
       - Import `getReverseIdentityMap` from `../plugin.js` (add to existing import from plugin.js on line 10)
       - In the tool factory closure (line 49), update:
         `const userId = deriveUserId(ctx.sessionKey, getReverseIdentityMap());`
         Called at factory execution time (per-session), reads the current cached reverse map.
  </action>
  <verify>npx vitest run</verify>
  <done>All 5 deriveUserId/deriveUserIdFromMessageCtx callsites pass the reverse identity map. Tool factory reads map via getReverseIdentityMap(). gateway_stop clears the map. Full test suite passes (existing tests unaffected since new parameter is optional).</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vitest run` — all tests pass (unit + integration)
- [ ] `npx tsc --noEmit` — no TypeScript errors
- [ ] New config field `identityMap` is optional (backward compatible)
- [ ] Derive functions work unchanged when no identityMap configured
- [ ] Reverse map validates no duplicate identities across groups
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- identityMap config option works: `{ "alice": ["telegram:12345", "discord:98765"] }`
- Same human on multiple channels resolves to single canonical userId
- No breaking changes to existing behavior when identityMap is absent
  </success_criteria>

<output>
After completion, create `.planning/phases/12-cross-channel-identity-mapping/12-01-SUMMARY.md`
</output>
