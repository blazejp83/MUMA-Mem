---
phase: 02-core-memory
plan: 05
type: execute
wave: 3
depends_on: ["02-02", "02-03", "02-04"]
files_modified: [src/pipeline/write.ts, src/pipeline/index.ts, src/tools/index.ts, src/plugin.ts, src/index.ts]
autonomous: true
---

<objective>
Compose the write pipeline orchestrator, register agent tools, and wire up episodic capture hooks.

Purpose: This integration plan connects all pipeline steps into a working write pipeline, exposes agent tools (PLUG-06), and adds episodic memory capture hooks (PLUG-04). After this plan, the memory system is functional end-to-end.
Output: write() orchestrator, 5 agent tools (memory.write/query/forget/pin/set_visibility), and 2 episodic hooks (message_received, after_tool_call).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/pipeline/extract.ts
@src/pipeline/construct.ts
@src/pipeline/retrieve.ts
@src/pipeline/decide.ts
@src/pipeline/link.ts
@src/pipeline/evolve.ts
@src/pipeline/read.ts
@src/plugin.ts
@src/index.ts
@src/types/note.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write pipeline orchestrator + agent tools</name>
  <files>src/pipeline/write.ts, src/tools/index.ts, src/pipeline/index.ts, src/index.ts</files>
  <action>
**src/pipeline/write.ts — Compose the full write pipeline**

Export:
```typescript
export interface WriteOptions {
  userId: string;
  agentId: string;
  source?: MemorySource;      // Default "experience"
}

export interface WriteResult {
  operation: WriteOperation;   // What happened
  note: Note | null;           // The created/updated note (null for DELETE/NOOP)
  targetNoteId?: string;       // For UPDATE/DELETE/NOOP: the existing note affected
  reason: string;              // LLM explanation
}

export async function write(
  input: string,
  options: WriteOptions,
): Promise<WriteResult>
```

Implementation — the full Extract→Construct→Retrieve→Decide→Link→Evolve chain:
1. Get providers: `const store = getStore(); const embedding = getEmbeddingProvider(); const llm = getLLMProvider();`
2. Extract: `const facts = await extract(input, llm);`
3. Construct: `const noteCreate = await construct(facts, embedding, options);`
4. Retrieve: `const similar = await retrieve(noteCreate, store);`
5. Decide: `const decision = await decide(noteCreate, similar, llm);`
6. Execute based on decision.operation:
   - **ADD**: `const note = await store.create(noteCreate);` then link and evolve
   - **UPDATE**: `await store.update(decision.targetNoteId, options.userId, { content: decision.mergedContent, context: facts.context, keywords: facts.keywords, tags: facts.tags, embedding: noteCreate.embedding });` then link and evolve on the updated note
   - **DELETE**: `await store.delete(decision.targetNoteId, options.userId);` — soft delete (store handles)
   - **NOOP**: No write — just return
7. For ADD/UPDATE — run link + evolve:
   - Read the created/updated note from store (to get full Note with ID)
   - `const linkResult = await link(note, store);`
   - `await evolve(note, linkResult.linkedNoteIds, store, llm);`
8. Return WriteResult

**src/tools/index.ts — Agent tools (PLUG-06)**

Export a function that registers tools on the plugin API:
```typescript
export function registerTools(api: any): void
```

Register 5 tools using api.registerTool() (OpenClaw plugin SDK pattern):

1. **memory.write** — Write a memory
   - Parameters: { content: string, source?: string }
   - Implementation: Calls write() with content, extracts userId and agentId from api context
   - Returns: { operation, noteId, reason }

2. **memory.query** — Search memories
   - Parameters: { query: string, topK?: number, expandLinks?: boolean }
   - Implementation: Calls search() from read pipeline
   - Returns: Array of { content, context, keywords, score, linkedNotes? }

3. **memory.forget** — Delete a memory
   - Parameters: { noteId: string }
   - Implementation: Calls store.delete(noteId, userId)
   - Returns: { success: boolean }

4. **memory.pin** — Pin/unpin a memory
   - Parameters: { noteId: string, pinned?: boolean }
   - Implementation: Calls store.update(noteId, userId, { pinned: pinned ?? true })
   - Returns: { success: boolean, pinned: boolean }

5. **memory.set_visibility** — Change memory visibility
   - Parameters: { noteId: string, visibility: string }
   - Implementation: Validates visibility is one of the four levels, calls store.update()
   - Returns: { success: boolean, visibility: string }

Each tool should have a name, description, parameters (JSON Schema), and execute function. Follow the OpenClaw tool registration pattern — check the plugin API for the exact method signature. Use `api.registerTool` if available, otherwise register tools via `api.on("register_tools", ...)` hook pattern.

IMPORTANT: The tool execute functions need userId and agentId from the request context. These should be available via the tool's execution context parameter (typically the second arg). Use `context.userId` and `context.agentId`. If the exact API shape is unclear, type the context parameter as `any` and access these fields — consistent with the existing `api: any` pattern in plugin.ts.

**Update src/pipeline/index.ts** — Add write pipeline exports:
```typescript
export { write } from "./write.js";
export type { WriteOptions, WriteResult } from "./write.js";
// Keep existing search exports
```

**Update src/index.ts** — Add write + tools exports:
```typescript
export { write } from "./pipeline/index.js";
export type { WriteOptions, WriteResult } from "./pipeline/index.js";
```
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>write() orchestrates full pipeline; 5 agent tools registered (memory.write/query/forget/pin/set_visibility); exports updated</done>
</task>

<task type="auto">
  <name>Task 2: Episodic capture hooks + plugin wiring</name>
  <files>src/plugin.ts</files>
  <action>
**PLUG-04: message_received and after_tool_call hooks capture episodic memories**

Update src/plugin.ts registerPlugin() to:

1. Import registerTools from ./tools/index.js
2. After gateway_start initialization, call registerTools(api)
3. Register episodic capture hooks:

**message_received hook:**
```typescript
api.on("message_received", async (event: any) => {
  // Only capture user messages (not system or assistant)
  if (event.role !== "user") return;
  // Skip short messages (less than 20 chars — greetings, acks)
  if (!event.content || event.content.length < 20) return;

  try {
    await write(event.content, {
      userId: event.userId,
      agentId: event.agentId ?? "unknown",
      source: "told",  // User told the agent this
    });
  } catch (err) {
    api.logger.warn(`[muma-mem] Episodic capture failed: ${err}`);
    // Non-blocking — don't break the conversation if memory fails
  }
});
```

**after_tool_call hook:**
```typescript
api.on("after_tool_call", async (event: any) => {
  // Only capture tool results that contain meaningful data
  if (!event.result || typeof event.result !== "string" || event.result.length < 50) return;

  try {
    const content = `Tool ${event.toolName} returned: ${event.result.substring(0, 500)}`;
    await write(content, {
      userId: event.userId,
      agentId: event.agentId ?? "unknown",
      source: "experience",  // Agent experienced this via tool
    });
  } catch (err) {
    api.logger.warn(`[muma-mem] Tool capture failed: ${err}`);
  }
});
```

Key design decisions:
- Hooks are non-blocking (catch errors, log warning, continue)
- Short messages filtered to avoid noise (greetings, "yes", "ok")
- Tool results truncated to 500 chars to avoid overwhelming the extract step
- Source is "told" for user messages, "experience" for tool results
- If LLM provider is not configured (getLLMProvider returns null), skip episodic capture silently — the hooks should check if llmProvider is available before attempting write()
  - Add a helper: check `llmProvider !== null` before calling write(). Since llmProvider is module-level state in plugin.ts, this is direct access.
  </action>
  <verify>npx tsc --noEmit passes; grep -q "message_received" src/plugin.ts; grep -q "after_tool_call" src/plugin.ts</verify>
  <done>Plugin registers tools on startup, message_received and after_tool_call hooks capture episodic memories via write pipeline</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds
- [ ] write() composes Extract→Construct→Retrieve→Decide→Link→Evolve
- [ ] 5 agent tools registered (memory.write, memory.query, memory.forget, memory.pin, memory.set_visibility)
- [ ] message_received hook captures user messages as "told" memories
- [ ] after_tool_call hook captures tool results as "experience" memories
- [ ] Hooks are non-blocking (errors logged, not thrown)
- [ ] All exports updated in pipeline/index.ts and index.ts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Full write pipeline works end-to-end (Extract→Construct→Retrieve→Decide→Link→Evolve)
- Agent tools expose memory operations (PLUG-06)
- Episodic hooks capture memories automatically (PLUG-04)
- No regressions in existing functionality
  </success_criteria>

<output>
After completion, create `.planning/phases/02-core-memory/02-05-SUMMARY.md`
</output>
