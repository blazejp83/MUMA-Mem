---
phase: 05-background-intelligence
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/cli/index.ts
  - src/cli/stats.ts
  - src/cli/export.ts
  - src/cli/consolidate.ts
  - src/cli/conflicts.ts
  - package.json
autonomous: true
---

<objective>
Create CLI subcommands for memory management: stats, export, consolidate, conflicts.

Purpose: CLI commands let users inspect, export, and manage their memory system outside of agent conversations. The CLI connects directly to the store (no plugin lifecycle needed) for standalone operation.
Output: `muma` CLI binary with 4 subcommands.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Genuinely needed — uses store enhancements and consolidation functions
@.planning/phases/05-background-intelligence/05-01-SUMMARY.md
@.planning/phases/05-background-intelligence/05-02-SUMMARY.md

@src/types/store.ts
@src/types/note.ts
@src/store/factory.ts
@src/config.ts
@src/consolidation/index.ts
@src/daemon/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI entry point with stats and export commands</name>
  <files>src/cli/index.ts, src/cli/stats.ts, src/cli/export.ts, package.json</files>
  <action>
  **Create src/cli/index.ts:**

  CLI entry point using Node.js built-in `util.parseArgs` (no external deps).
  - Shebang: `#!/usr/bin/env node`
  - Parse subcommand from positional args: `muma stats`, `muma export`, `muma consolidate`, `muma conflicts`
  - Global options: `--config <path>` (config JSON file, default: look for `.muma.json` in cwd then home dir), `--user <userId>` (required for most commands)
  - On unknown/missing subcommand, print help text listing available commands
  - Initialize store directly via `createStore(config)` — no plugin lifecycle
  - Close store on exit

  Config loading strategy:
  1. If `--config` provided, read that file
  2. Else look for `.muma.json` in cwd
  3. Else look for `~/.muma.json`
  4. Else use defaults (SQLite at `~/.muma/memory.db`)
  - Parse with MumaConfigSchema for validation

  **Create src/cli/stats.ts:**
  Export `async function statsCommand(store: MemoryStore, userId: string): Promise<void>`
  - CLI-01: Memory counts, storage usage, activation distribution
  - Count total memories: `store.countByUser(userId)`
  - Fetch all notes: `store.listByUser(userId, { limit: 1000 })`
  - Compute activation distribution:
    - High (> 2.0), Medium (0 to 2.0), Low (< 0)
  - Compute domain distribution: count notes per domain
  - Compute age stats: oldest, newest, median age
  - Print formatted table to stdout:
    ```
    Memory Stats for user: {userId}
    ─────────────────────────────
    Total memories:  {N}
    Backend:         {redis|sqlite}

    Activation Distribution:
      High (>2.0):   {N} ({pct}%)
      Medium (0-2):  {N} ({pct}%)
      Low (<0):      {N} ({pct}%)

    Top Domains:
      {domain}: {N} notes
      ...

    Pinned: {N}
    Pruning candidates: {N}
    ```

  **Create src/cli/export.ts:**
  Export `async function exportCommand(store: MemoryStore, userId: string, outputPath?: string): Promise<void>`
  - CLI-02: JSON dump of all memories with metadata
  - Fetch all notes: `store.listByUser(userId, { limit: 10000 })`
  - Serialize to JSON with all fields EXCEPT embedding (binary, not useful in JSON)
  - Convert embedding to `{ dimensions: N, omitted: true }` placeholder
  - Write to outputPath (default: `muma-export-{userId}-{date}.json`)
  - Print: `Exported {N} memories to {path}`
  - Add `--output <path>` option parsed in CLI entry point

  **Update package.json:**
  Add `"bin"` field:
  ```json
  "bin": {
    "muma": "dist/cli/index.js"
  }
  ```
  </action>
  <verify>npm run build succeeds; node dist/cli/index.js --help prints usage; typecheck passes</verify>
  <done>CLI entry point works with stats and export subcommands, bin field added to package.json</done>
</task>

<task type="auto">
  <name>Task 2: Add consolidate and conflicts CLI commands</name>
  <files>src/cli/consolidate.ts, src/cli/conflicts.ts, src/cli/index.ts</files>
  <action>
  **Create src/cli/consolidate.ts:**
  Export `async function consolidateCommand(store, embedding, llm, userId): Promise<void>`
  - CLI-03: Trigger manual consolidation
  - Import and call `consolidate(userId, store, embedding, llm)` from consolidation module
  - Import and call `distillMemoryMd(userId, store, llm)` then `writeMemoryMdFile(content, userId)`
  - Print the ConsolidationReport in readable format:
    ```
    Consolidation Complete for user: {userId}
    ─────────────────────────────────────────
    Clusters found:           {N}
    Summaries created:        {N}
    Conflicts detected:       {N}
      Auto-resolved:          {N}
      Needs review:           {N}
    MEMORY.md updated:        {path}
    ```
  - If LLM not configured, print error and exit: "Consolidation requires LLM configuration. Set llm.apiKey and llm.model in config."

  **Create src/cli/conflicts.ts:**
  Export `async function conflictsCommand(store: MemoryStore, userId: string, showResolved?: boolean): Promise<void>`
  - CLI-04: List detected memory conflicts
  - Fetch conflicts: `store.getConflicts({ resolved: showResolved ? undefined : false })`
  - Filter by userId (check noteIdA/B belong to user — fetch the notes to verify)
  - Print formatted list:
    ```
    Memory Conflicts for user: {userId}
    ─────────────────────────────────────
    [1] CONTRADICTORY (unresolved)
        Note A: "{content preview...}" ({noteIdA})
        Note B: "{content preview...}" ({noteIdB})
        Description: {description}

    [2] AMBIGUOUS (unresolved)
        ...

    Total: {N} unresolved conflicts
    ```
  - Add `--all` flag to show resolved conflicts too
  - If no conflicts found: "No unresolved conflicts found."

  **Update src/cli/index.ts:**
  - Wire consolidate and conflicts subcommands
  - For consolidate: also initialize embedding provider and LLM provider via factories
  - For conflicts: only needs store
  - Add `--all` flag parsing for conflicts command
  - Add `--output` flag parsing for export command
  </action>
  <verify>npm run typecheck passes; npm run build succeeds; node dist/cli/index.js consolidate --help and conflicts --help work</verify>
  <done>All 4 CLI commands work: stats (CLI-01), export (CLI-02), consolidate (CLI-03), conflicts (CLI-04)</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes
- [ ] `npm run build` succeeds
- [ ] `node dist/cli/index.js` prints help
- [ ] `node dist/cli/index.js stats --user test` runs without errors (may show empty stats)
- [ ] `node dist/cli/index.js export --user test` creates JSON file
- [ ] All 4 subcommands accessible
- [ ] bin field in package.json points to correct entry
</verification>

<success_criteria>
- All tasks completed
- CLI-01: stats command shows counts, activation distribution, domains
- CLI-02: export command creates JSON dump with metadata
- CLI-03: consolidate command triggers full pipeline
- CLI-04: conflicts command lists unresolved conflicts
- No external CLI dependencies added (uses Node.js built-in parseArgs)
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/05-background-intelligence/05-04-SUMMARY.md`
</output>
