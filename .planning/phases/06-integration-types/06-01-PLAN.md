---
phase: 06-integration-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/openclaw.ts
  - src/index.ts
  - src/utils/deriveUserId.ts
  - src/utils/__tests__/deriveUserId.test.ts
autonomous: true
---

<objective>
Establish OpenClaw type foundations for the v1.1 integration milestone.

Purpose: Replace all `any` types in the plugin integration layer with concrete OpenClaw SDK types, create the `deriveUserId` helper that all subsequent phases need, and fix the plugin definition shape. This is the foundation phase — Phases 7 (hooks), 8 (tools), and 9 (CLI) all depend on these types.

Output: OpenClaw type definitions file, deriveUserId utility with tests, fixed plugin definition.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/INTEGRATION-SPEC.md

@src/index.ts
@src/plugin.ts
@src/types/note.ts
@src/types/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenClaw plugin SDK type definitions and fix plugin definition</name>
  <files>src/types/openclaw.ts, src/index.ts</files>
  <action>
Create `src/types/openclaw.ts` with TypeScript types mirroring the actual OpenClaw plugin SDK. These are LOCAL type definitions (no npm dependency needed) — the real SDK types live in the obsolete OpenClaw repo but are not published as an npm package.

Define the following types based on INTEGRATION-SPEC.md:

**Plugin API (Section 2):**
- `PluginLogger` — `{ debug?: (...args: unknown[]) => void; info: ...; warn: ...; error: ... }`
- `OpenClawPluginApi` — the `api` object passed to `register()`. Include: `id`, `name`, `version?`, `description?`, `source`, `config: unknown`, `pluginConfig?: Record<string, unknown>`, `logger: PluginLogger`, `registerTool`, `registerHook`, `registerCli`, `on`, `resolvePath`. Omit unused methods (registerHttpHandler, registerChannel, etc.) — add them later when needed.

**Hook event/context types (Section 3):**
- `PluginHookBeforeAgentStartEvent` — `{ prompt: string; messages?: unknown[] }`
- `PluginHookAgentContext` — `{ agentId?: string; sessionKey?: string; sessionId?: string; workspaceDir?: string; messageProvider?: string }`
- `PluginHookBeforeAgentStartResult` — `{ systemPrompt?: string; prependContext?: string }`
- `PluginHookSessionEndEvent` — `{ sessionId: string; messageCount: number; durationMs?: number }`
- `PluginHookSessionEndContext` — `{ agentId?: string; sessionId: string }`
- `PluginHookMessageReceivedEvent` — `{ from: string; content: string; timestamp?: number; metadata?: Record<string, unknown> }`
- `PluginHookMessageReceivedContext` — `{ channelId: string; accountId?: string; conversationId?: string }`
- `PluginHookAfterToolCallEvent` — `{ toolName: string; params: Record<string, unknown>; result?: unknown; error?: string; durationMs?: number }`
- `PluginHookAfterToolCallContext` — `{ agentId?: string; sessionKey?: string; toolName: string }`
- `PluginHookGatewayStartEvent` — `{ port: number }`
- `PluginHookGatewayStopEvent` — `{ reason?: string }`
- `PluginHookGatewayContext` — `{ port?: number }`

**Tool types (Section 4):**
- `OpenClawPluginToolContext` — `{ config?: unknown; workspaceDir?: string; agentDir?: string; agentId?: string; sessionKey?: string; messageChannel?: string; agentAccountId?: string; sandboxed?: boolean }`
- `AgentTool` — `{ label: string; name: string; description: string; parameters: Record<string, unknown>; execute: (toolCallId: string, params: unknown) => unknown | Promise<unknown> }`
- `OpenClawPluginToolFactory` — `(ctx: OpenClawPluginToolContext) => AgentTool | AgentTool[] | null | undefined`
- `OpenClawPluginToolOptions` — `{ name?: string; names?: string[]; optional?: boolean }`

**CLI types (Section 6):**
- `OpenClawPluginCliContext` — `{ program: unknown; config: unknown; workspaceDir?: string; logger: PluginLogger }`
- `OpenClawPluginCliRegistrar` — `(ctx: OpenClawPluginCliContext) => void`

**Plugin definition:**
- `OpenClawPluginDefinition` — `{ id?: string; name?: string; description?: string; version?: string; kind?: string; configSchema?: unknown; register?: (api: OpenClawPluginApi) => void | Promise<void>; activate?: (api: OpenClawPluginApi) => void | Promise<void> }`

Export all types. Do NOT use `import type` from any openclaw package — these are self-contained local definitions.

Then fix `src/index.ts`:
- Import `OpenClawPluginDefinition` from `./types/openclaw.js`
- Add `version: "0.1.0"` to the plugin definition object
- Type the plugin definition as `OpenClawPluginDefinition`
- Re-export all OpenClaw types from the package: `export type { ... } from "./types/openclaw.js"`
  </action>
  <verify>pnpm run typecheck passes with no errors</verify>
  <done>src/types/openclaw.ts exists with all OpenClaw SDK types. src/index.ts has `version: "0.1.0"` and typed plugin definition. All types re-exported from package entry point.</done>
</task>

<task type="auto">
  <name>Task 2: Create deriveUserId utility with tests</name>
  <files>src/utils/deriveUserId.ts, src/utils/__tests__/deriveUserId.test.ts</files>
  <action>
Create `src/utils/deriveUserId.ts` with two functions:

**`deriveUserId(sessionKey?: string): string`**
- Parses OpenClaw sessionKey format: `"channel:peerId"` or `"channel:peerId:agentId"`
- Returns `"channel:peerId"` as the userId (first two segments)
- Returns `"default"` if sessionKey is undefined, empty, or has no colon
- Examples:
  - `deriveUserId("telegram:12345:agent1")` → `"telegram:12345"`
  - `deriveUserId("telegram:12345")` → `"telegram:12345"`
  - `deriveUserId("discord:98765:helper")` → `"discord:98765"`
  - `deriveUserId(undefined)` → `"default"`
  - `deriveUserId("")` → `"default"`
  - `deriveUserId("standalone")` → `"default"` (no colon = can't parse)

**`deriveUserIdFromMessageCtx(ctx: { channelId: string; accountId?: string }): string`**
- For `message_received` hook context which has different fields
- Returns `"channelId:accountId"` if accountId exists
- Returns `channelId` if no accountId
- Examples:
  - `deriveUserIdFromMessageCtx({ channelId: "telegram", accountId: "12345" })` → `"telegram:12345"`
  - `deriveUserIdFromMessageCtx({ channelId: "cli" })` → `"cli"`

Export both functions.

Create `src/utils/__tests__/deriveUserId.test.ts` with vitest tests covering:
- sessionKey with 3 segments (channel:peerId:agentId)
- sessionKey with 2 segments (channel:peerId)
- sessionKey with 1 segment (no colon)
- undefined sessionKey
- empty string sessionKey
- message context with both channelId and accountId
- message context with only channelId

Also create `src/utils/index.ts` barrel export re-exporting from deriveUserId.

Update `src/index.ts` to re-export: `export { deriveUserId, deriveUserIdFromMessageCtx } from "./utils/index.js"`
  </action>
  <verify>pnpm run test -- src/utils/__tests__/deriveUserId.test.ts passes all tests. pnpm run typecheck passes.</verify>
  <done>deriveUserId and deriveUserIdFromMessageCtx functions exist and exported. All test cases pass. Functions available from package entry point.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm run typecheck` passes with no errors
- [ ] `pnpm run test` passes (including new deriveUserId tests)
- [ ] `pnpm run build` succeeds
- [ ] src/types/openclaw.ts contains all OpenClaw SDK type definitions
- [ ] src/utils/deriveUserId.ts exports deriveUserId and deriveUserIdFromMessageCtx
- [ ] src/index.ts has version field and typed plugin definition
- [ ] All new types and utilities re-exported from package entry point
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- OpenClaw types available for Phases 7-9 to consume
- deriveUserId helper ready for hook and tool rewrites
- Plugin definition matches OpenClaw expected shape
</success_criteria>

<output>
After completion, create `.planning/phases/06-integration-types/06-01-SUMMARY.md`
</output>
